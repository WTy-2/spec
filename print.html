<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The WTy2 Language Specification</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="core_types.html"><strong aria-hidden="true">2.</strong> Core Types</a></li><li class="chapter-item expanded "><a href="declarations.html"><strong aria-hidden="true">3.</strong> Declarations</a></li><li class="chapter-item expanded "><a href="dependent_types.html"><strong aria-hidden="true">4.</strong> Dependent Types</a></li><li class="chapter-item expanded "><a href="erasure_visibility.html"><strong aria-hidden="true">5.</strong> Erasure and Visibility</a></li><li class="chapter-item expanded "><a href="recursive_types.html"><strong aria-hidden="true">6.</strong> Recursive Types</a></li><li class="chapter-item expanded "><a href="proofs.html"><strong aria-hidden="true">7.</strong> Proofs</a></li><li class="chapter-item expanded "><a href="io_ex.html"><strong aria-hidden="true">8.</strong> IO and the Ex Monad</a></li><li class="chapter-item expanded "><a href="allocators.html"><strong aria-hidden="true">9.</strong> Type Aware Allocators</a></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">10.</strong> Utilities</a></li><li class="chapter-item expanded "><a href="specialisation.html"><strong aria-hidden="true">11.</strong> Specialisation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The WTy2 Language Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WTy-2/spec/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>WTy2 is a dependently typed, functional and imperative programming language.</p>
<p>It was designed with a few goals in mind:</p>
<ul>
<li>Aim for there to be exactly one &quot;best&quot; way to design every abstraction. If there has to be multiple, the relative trade-offs for each should be obvious and small in number.</li>
<li>Allow extremely strong compile-time guarantees (via dependent types), but optionally. It should be possible to start with a program that relies heavily on run-time assertions and bit-by-bit introduce more and more static checks without major refactoring.</li>
<li>Possible to obtain really fast performance, without a language runtime. WTy2 is designed to eventually be a capable systems programming language, meaning abstractions should ideally be close to zero-cost. WTy2 features linear types, unboxed types (including unboxed closures), and a novel approach to monomorphisation, where the compiler falls back on runtime dispatch (meaning C++/Rust-level performance in the best case, without restrictions on the size of types).</li>
<li>WTy2 collections are also built using a novel concept of &quot;type-aware allocators&quot;, that provide <strong>blazing fast</strong> <code>fmap</code> performance where order of traversal is unimportant.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-types"><a class="header" href="#core-types">Core Types</a></h1>
<p>WTy2 is a language with subtyping and with first-class types. This has an interesting consequence: instead of having some sort of &quot;kind&quot; system, the key language constructs in WTy2 simply implement various built-in types.</p>
<h2 id="any-"><a class="header" href="#any-">Any (&quot;?&quot;)</a></h2>
<p><code>?</code> is the supertype of all types.</p>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p><code>Type</code> is the supertype of all &quot;types&quot;. This includes anything which can appear on the RHS of a <code>:</code> binding.</p>
<p>An automatic instance of <code>Type</code> is derived for every type declaration.</p>
<h2 id="constraint"><a class="header" href="#constraint">Constraint</a></h2>
<p><code>Constraint</code> represents &quot;constraints&quot;. These sometimes look syntactically similar to bindings, but instead of bringing variables into scope, they constrain existing values.</p>
<p>Constraints can be created with the built-in <code>~</code> and <code>=&gt;</code> operators. Every type <code>a</code> also implements <code>a -&gt; Constraint</code>, which is the constraint that there exists an instance of the type for that term. i.e: you can imagine for every type <code>Foo</code>:</p>
<pre><code class="language-WTy2">instance Foo -&gt; Constraint for Foo {
    ...
}
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p><code>a -&gt; b</code> is the generic function type.</p>
<h2 id="tuplesrecordsdependent-pairs"><a class="header" href="#tuplesrecordsdependent-pairs">Tuples/Records/Dependent Pairs</a></h2>
<p>Tuples/records/dependent pairs in WTy2 are surprisingly complicated, and so they have their own dedicated section in the spec.</p>
<p>It's worth noting though, that combining the above constructs in tuples typically gives back something that implements the same type.</p>
<ul>
<li>Tuple of <code>Type</code>s =&gt; <code>Type</code> (anonymous tuple type)</li>
<li>Tuple of <code>Constraint</code>s =&gt; <code>Constraint</code> (conjunction)</li>
</ul>
<p>However...</p>
<ul>
<li>Tuple of <code>Bind</code>ings =&gt; <code>Type</code> (record type)</li>
</ul>
<h3 id="unit-"><a class="header" href="#unit-">Unit (&quot;()&quot;)</a></h3>
<p><code>()</code> is the unit tuple. It implements <code>Type</code>, <code>Term</code> AND <code>Constraint</code>.</p>
<h3 id="design-note-singleton-tuples"><a class="header" href="#design-note-singleton-tuples">Design Note: Singleton Tuples</a></h3>
<p>WTy2 does not contain a built-in singleton tuple (but does contain singleton records). Instead <code>(X)</code> where <code>X</code> does not contain commas is parsed as a parenthesised expression.</p>
<h3 id="design-note-bindings"><a class="header" href="#design-note-bindings">Design Note: Bindings</a></h3>
<p>In WTy2, the types of records look almost identical to <code>Bind</code>ings. However, <code>Bind</code>ings are NOT first-class. <code>return (x: Int)</code> returns a <code>Type</code> which is equal to the record type <code>(x: Int)</code>. <code>{x : Int}() = 4</code> is not a valid way to bring <code>x</code> into scope.</p>
<h2 id="void-"><a class="header" href="#void-">Void (&quot;!&quot;)</a></h2>
<p><code>!</code> is the subtype of all types. It contains no inhabitants.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declarations"><a class="header" href="#declarations">Declarations</a></h1>
<p>WTy2 supports top-level bindings in the form of &quot;declarations&quot;.</p>
<p>All named declarations can be prefixed with visibility annotations.</p>
<h2 id="type-declarations"><a class="header" href="#type-declarations">Type Declarations</a></h2>
<p>Type declarations define &quot;types&quot;. Note types in WTy2 are quite different from types in many other languages: for instance, types can be open, allowing instances for the type to be made apart from it's declaration.</p>
<p>Note &quot;type&quot;s in WTy2 were originally named &quot;trait&quot;s for this very reason. I have since decided it makes more sense to just call them &quot;type&quot;s because there is no other construct in the language which fits the same role.</p>
<p>Open types can have a number of associated functions that must be defined at instances of that type. In these functions, there is an implicit constant <code>self: Type</code> in scope which refers to the instance head.</p>
<p>Supertypes of the type are optionally explicitly declared after the <code>{}</code>s with <code>=&gt;</code>.</p>
<p>As an example, here is the <code>MonadC</code> type, which is similar to a <code>Monad</code> in functional languages like <code>Haskell</code> but is not total (meaning it can support data structures like sets and hashmaps)</p>
<pre><code class="language-WTy2">type MonadC(c: Type) {

    fmap[a: c, b: c](x: self(a), f: a -&gt; b): self(b)

    pure[a: c](x: a): self(a)

    (&gt;&gt;=)[a: c, b: c](x: self(a), f: a -&gt; self(b)): self(b)

} =&gt; c -&gt; Any
</code></pre>
<p><sup class="footnote-reference"><a href="#note">1</a></sup></p>
<h3 id="type-synonyms"><a class="header" href="#type-synonyms">Type Synonyms</a></h3>
<p>Sometimes a type is desired that is simply a synonym for some other more elaborate type. As types are first class, this can be implemented in WTy2 just with ordinary functions; however, functions have slightly different semantics to distinct types (functions reduce, while types do not) which can impact typechecking and inference.</p>
<p>Type synonyms can be alternatively written by simply declaring a type with the appropriate supertype constraint and then writing a single instance:</p>
<pre><code class="language-WTy2">type Alias {} =&gt; Foo

default instance Alias for Foo
</code></pre>
<p>Because this pattern is so common, WTy2 provides syntax sugar for it:</p>
<pre><code>type Alias = Foo
</code></pre>
<p>As coherence rules enforce that instances where the instance head is an open type prevent any other instances being written, it is suggested that ideal practice when writing an open-head instance is to instead write a type alias. Implementations may wish to warn the programmer in scenarios where this is not done.</p>
<h2 id="instance-declarations"><a class="header" href="#instance-declarations">Instance Declarations</a></h2>
<h3 id="coherence-and-orphan-rules"><a class="header" href="#coherence-and-orphan-rules">Coherence and Orphan Rules</a></h3>
<p>It is critical to soundess of the WTy2 language that instances do not overlap. The rules for avioding overlap can be summarised as:</p>
<ul>
<li>If the instance head is open, that instance must be in the same module as the type declaration and no other instances can be written.</li>
<li>If the instance head is closed, either the instance must be in the same module as the type declaration, or all implementing patterns must contain at least one variant tag that was defined in the same module (in other words: it must be impossible to write this instance in some other module without importing the one you are writing the instance in).</li>
</ul>
<h3 id="named-instances"><a class="header" href="#named-instances">Named Instances</a></h3>
<p>WTy2 supports &quot;named instances&quot; as an alternative to the newtype pattern.</p>
<p>The exact semantics and syntax of this feature are WIP, but the goal is to have something at least as powerful as Haskell's &quot;deriving via&quot; extension: enabling overridable default superclass instances.</p>
<h2 id="data-declarations"><a class="header" href="#data-declarations">Data Declarations</a></h2>
<p>Data declarations define &quot;variants&quot;. These appear similar to functions but instead of producing arbitrary values after executing some computation, they create tagged versions of whatever type they are declared to take as parameter.</p>
<p>The suggested implementation is for tags to all share the same 32-bit space of values. As an optimisation, it is suggested that this tag is elided in cases where it is known at compile-time.</p>
<p>I.e: In the below program</p>
<pre><code class="language-WTy2">data Foo(Bar)

x: Bar = ...
y: Foo = Foo(x)
</code></pre>
<p>Both <code>Foo</code> and <code>Bar</code> should have equivalent runtime representations.</p>
<p>Handling variance while ensuring unnecessary tag information is not stored at runtime is not a trivial problem: for how this is solved specifically with regards to recursive types (which is the arguably most awkward one), see the dedicated section.</p>
<h2 id="functionconstant-declarations"><a class="header" href="#functionconstant-declarations">Function/Constant Declarations</a></h2>
<p>Ordinary terms like functions or constants can also be defined as top level bindings. They do not need to be prefixed with any keyword.</p>
<h3 id="proof-declarations"><a class="header" href="#proof-declarations">Proof Declarations</a></h3>
<p>However, functions can be optionally be prefixed with the <code>proof</code> keyword. This changes the semantics of the binding, allowing calls to the function to be inserted automatically to aid typechecking. Proofs my also be anonymous. See the dedicated section on proofs for more information.</p>
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>Note that with function contravariance, we could also have <code>f: c -&gt; b</code> in <code>fmap</code>, and if <code>MonadC</code> itself was contravariant, <code>x: self(c)</code> and then no need for <code>a</code>. WTy2 currently does not support variance due to added complexity, but code like this shows places where it could be very useful.</p>
</div>
<p>Also note the the <code>a: c</code> and <code>b: c</code> constraints here are slightly tiresome. Arguably these could be inferred from their use as arguments to <code>self</code>. There has been some research in Haskell on doing this inference https://richarde.dev/papers/2020/partialdata/partialdata.pdf and it appears to be highly effective in practice (though it is unclear how well it will extend to a language with subtyping).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependent-types"><a class="header" href="#dependent-types">Dependent Types</a></h1>
<p>WTy2 features dependent record and function types.</p>
<h2 id="constrained-by-"><a class="header" href="#constrained-by-">Constrained By <code>(&lt;==)</code></a></h2>
<p>Often, in dependently typed languages, a dependent record only needs to carry evidence of a constraint as the second argument, for the purpose of bringing it into scope as evidence of a predicate. This pattern is made more convenient in WTy2 through the <code>&lt;==</code> operator (read as &quot;constrained by&quot;).</p>
<p>The <code>&lt;==</code>operator has the following type signature:</p>
<pre><code class="language-WTy2">(&lt;==) : (a: Type, f: a -&gt; Constraint) -&gt; Type
</code></pre>
<p>To construct a value of type <code>a &lt;== b</code> from a value <code>x</code> of type <code>a</code>, <code>b(x)</code> must be in the context. Matching on a value of type <code>(x: a) &lt;== b</code> is similar to matching on a value of type <code>a</code>, but <code>b(x)</code> is added to the context.</p>
<p>In use, this operator has similarities to refinement types (i.e: in Liquid Haskell) (i.e: in that the constraint evidence is passed entirely implicitly).</p>
<p>An approximation of this operator in Idris (but for which construction and matching is not implicit) could be defined like so:</p>
<pre><code class="language-idris">Proof : Bool -&gt; Type
Proof p = p = True

data (&lt;==) : (a: Type) -&gt; (p: a -&gt; Bool) -&gt; Type where
  Mk : (x: a) -&gt; (f: Proof (p x)) -&gt; ((&lt;==) a p)

infix 4 &lt;==
</code></pre>
<p>Idris (as far as I am aware) does not have an equivalent of equality coercion constraints like WTy2 (or indeed Haskell) so we are forced to use <code>-&gt; Bool</code> and propositional equality <code>=</code> to represent predicates instead.</p>
<p>An example use would be to restrict the integers received by a function:</p>
<pre><code class="language-idris">total
foo : (Nat &lt;== \x =&gt; 1 &lt;= x &amp;&amp; x &lt;= 3) -&gt; ()
test3 (Mk 1 {f=Refl}) = ()
test3 (Mk 2 {f=Refl}) = ()
test3 (Mk 3 {f=Refl}) = ()
</code></pre>
<p>We can see that although <code>foo</code> only matches on the natural number being <code>1</code>, <code>2</code> or <code>3</code>, the function is still correctly typechecked as <code>total</code>, as we must also pass a proof that the <code>Nat</code> is in the range <code>[1-3]</code>.</p>
<p>The equivalent WTy2 declaration of <code>foo</code> is:</p>
<pre><code class="language-WTy2">foo(x: Nat) &lt;== { 1 &lt;= x &amp;&amp; x &lt;= 3 ~ True }
</code></pre>
<p>This sort of constraint is useful enough that defining a type synonym is probably a good idea.</p>
<pre><code>type NatBetween(min: Nat, max: Nat)
    = Nat &lt;== { min &lt;= it &amp;&amp; it &lt;= max ~ True }

foo(x: NatBetween(1, 3))
</code></pre>
<p>As records can have multiple entries we can easily constrain arguments in terms of another. For example, we can define a function <code>bar</code> which takes two <code>Nat</code>s, <code>x</code> and <code>y</code>, where <code>y</code> must be greater than <code>x</code>:</p>
<pre><code>bar(x: Nat, y: Nat) &lt;== { y &gt; x ~ True }
</code></pre>
<h3 id="design-note-equivalent-constraints"><a class="header" href="#design-note-equivalent-constraints">Design Note: Equivalent Constraints</a></h3>
<p>You may realise that as constraints can contain arbitrary expressions, we could formulate these constraints in many different ways. For example, we could write <code>{ contains([1, 2, 3], it) ~ True }</code>, or even <code>{ max(1, min(3, it)) ~ it }</code>. That these constraints do indeed imply each other though, is not always obvious (expecially to the typechecker).</p>
<p>This is arguably the main pain-point with dependent types - proving that one constraint implies another can be tiresome and clutter up code significantly. WTy2 attempts to make this slightly less painful through the ability to write implicit <code>proof</code>s.</p>
<h2 id="dependent-function-arrow"><a class="header" href="#dependent-function-arrow">Dependent Function Arrow</a></h2>
<p>WTy2 also supports dependent function arrows, through a similar mechanism. The argument record to a function is in scope in the return type (including the return constraint), as well as the function body.</p>
<p>Note this makes <code>&lt;==</code> constraints on return types somewhat ambiguous in that if the return type of the function is a record with identically named fields (or simply the <code>it</code> keyword is used), this could refer to the argument record or the return. WTy2 disambiguates this by treating this case as shadowing. In general, the innermost <code>it</code> (and it's associated record names) shadow the outermost one.</p>
<p>Currently, there is no mechanism to forcefully disambiguate (though perhaps some syntax to specify de Bruijn indices or similar could work). The field names of the argument or return record must be changed to refer to the argument record fields in the return constraint.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erasure-and-visibility"><a class="header" href="#erasure-and-visibility">Erasure and Visibility</a></h1>
<p>In WTy2, erasure and visibility are intrinsically linked. WTy2 will only ever infer values that will be erased at runtime.</p>
<p>A type surrounded in parenthesis can be prefixed with something that looks similar to a record type but the bindings are placed inside brackets (<code>[]</code>) instead of parenthesis.</p>
<p>A term can be bound in the erased elements of a record only if it occurs (to the right of some constraint operator<sup class="footnote-reference"><a href="#note">1</a></sup>) or <code>:</code> in the non-erased elements.</p>
<p>An example of erasure being useful is when working with length-indexed vectors:</p>
<pre><code class="language-WTy2">vecLen[t: Type, n: Nat](v: Vec(t, n)): Nat &lt;== { it ~ n }

returnsVecOfUnknownLen(...): [n: Nat] Vec[Bool, n]
</code></pre>
<p>In <code>vecLen</code>, binding <code>t</code> and <code>n</code> in the <code>[]</code>s allows them to be inferred, and makes it so there is no runtime cost of having to pass the type or length. Note if we had to pass the length explicitly, then the function would be entirely useless: we would need to know the length to calculate it!</p>
<p>This combines nicely with functions like <code>returnsVecOfUnknownLen</code>. If we ever do actually need to know the length (perhaps to pattern match on it), then we can call <code>vecLen</code> on the result, and this all works out because we still have an erased <code>n: Nat</code> in scope.</p>
<p>To be concrete, a term being erased means that it cannot be pattern matched on, or passed as an argument to somewhere where a non-erased term is expected.</p>
<p>Unlike constraints in <code>&lt;==</code>, erased terms in records can be manually specified at construction or bound when matching.</p>
<pre><code class="language-WTy2">[erasedLen=n] vec = returnsVecOfUnknownLen(...);
len = vecLen[Bool, erasedLen](vec);

// From the signature of 'vecLen', `erasedLen ~ len` is in the context
_: () &lt;== { erasedLen ~ len } = ();
</code></pre>
<h2 id="infering-from-return-type"><a class="header" href="#infering-from-return-type">Infering From Return Type</a></h2>
<p>One unfortunate consequence of handling inference in this way is that inference based on return type is not really possible. This can be a useful feature - for example, in languages like Haskell, all integer literals have type <code>Num a =&gt; a</code>, meaning they can appear in any numeric expression without a need to cast them to the correct numeric type.</p>
<p><sup class="footnote-reference"><a href="#note">1</a></sup>
The exact condition with constraint operators which makes it legal for a variable to be erased and inferred is a work-in-progress. In theory we only want to allow erasure if there is a possibility that it can be inferred, but detecting this is potentially non-trivial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h1>
<p>Elsewhere in this spec (I may go back and fix it up later), I have been relatively loose with defining types like:</p>
<pre><code class="language-WTy2">data Cons(head: t, tail: List(t))
data Nil

type List(t: Type) = [head: t, tail: List(t)]
                     Is(Cons(head, tail))
                   | Is(Nil)
</code></pre>
<p>Unfortunately, there is a bit of an issue with values of this type - they have unbounded size! Specifically, if a function takes a <code>List(Int)</code>, for example, the actual list it could receive could have any number of <code>Cons</code> nodes.</p>
<p>Furthermore, it is not clear how to implement variance for this type. If we have a <code>List(Int)</code>, then ideally at each node we would not store any information informing us that the item is an <code>Int</code> (we can know that it could be nothing else from the type signature). However, we would like to be able to pass this into functions accepting say <code>List(Num)</code>, this would seemingly require creating an entirely new list with the <code>Int</code> marker placed on every node.</p>
<p>One potential solution is to simply not use recursive types. WTy2 supplies a an array list type that is fast and provides great memory locality. In languages like Haskell and Closure, however, the utility of being able to create many large data structures that share data cannot really be understated. As a functional language with pattern matching, WTy2 really should be able to achieve something similar.</p>
<p>The way we can achieve this is through references, but perhaps in a slightly different way to what you might imagine coming from languages like Rust.</p>
<pre><code>data Cons[r: Ref](head: t, tail: List(r, t))
data Nil
type List(r: Ref, t: Type) = r(
    [head, tail: List(r, t)] Is(Cons(head, tail))
                           | Is(Nil)
    )
</code></pre>
<p>The main interesting thing about this definition is that <code>r</code>, the type variable that will be instantiated to some sort of reference that will break up the infinite type, is generic. We could instantiate <code>r</code> to some owning reference type like <code>Box</code> and get a definition similar to what we would achieve in Rust, but we can do better.</p>
<p>The problem with <code>Box</code> or any other global allocator is that we lose locality. If the elements are added to the list randomly over time, then they will be placed in effectively random locations in memory. What we would like is for every element of the same list to be placed in more-or-less the same location (note this idea is similar to that of arenas in Rust).</p>
<pre><code>type Alloc = ...
type RefTo(a: Alloc, t: Type) = ...

// Get the allocator of a reference
allocOf[a: Alloc, t: Type](r: RefTo(a, t)): Alloc &lt;== { it ~ a }

// Would be a method of the 'Alloc' type
alloc(a: Alloc, t: Type): RefTo(a, t)

// Create a new allocator and allocate an expression using it
new[t](x: t): [a] RefTo(a, t)

// Function application, but wrap in the allocator at the end
build[a: Alloc, t: Type](x: RefTo(a, t), f: RefTo(a, t) -&gt; t)
    : RefTo(a, t) = alloc(allocOf(x), f(x))

// We take advantage of partial signatures to not need to specify the allocator
// in the signatures of 'x' or 'y'
x: List(t=Int) = new(Nil)
y: List(t=Int) = build(x) { Cons(3, it) }


// Alternate style, arguably neater but requires some extra busywork

type ConsLike(r, t) = [head: t, tail: List(r, t)] Is(Cons(head, tail))

// Would likely be a method of some type
// '(,..)' denotes partial application
// (i.e: will fill in the other arguments later)
allocOfCons[a: Alloc, r: RefTo(a,..), t: Type]
    (x: ConsLike(r, t)): Alloc &lt;== { it ~ a  }
    = match(x) case(Cons(_, tail)) -&gt; allocOf(tail)


altBuild[a: Alloc, r: RefTo(a,..), t: Type]
    (x: ConsLike(r, t)): List(r, t)
    = alloc(allocOfCons(x), x)


z: List(t=Int) = altBuild(Cons(3, x))
</code></pre>
<p>There are some interesting interactions with enforcing code like this: for example, if you have two different lists, potentially created with different allocators, the elements from one allocator must be all copied into the other. Because of this, it is recommended that if an algorithm involves a lot of merging of linked data structures, there is a single allocator created once and all sub-structures are creates with it.</p>
<p>Note that using allocators like this also helps with the variance problem as mentioned above. Allocators in WTy2 are type-aware. Allocators must provide a way of recovering full type information for every value that is stored by them, but to ensure memory is not wasted, elements with common type prefixes are stored together. The exact mechanism for how to find the prefix is WIP but one could imagine, for instance, a binary tree which is traversed based on the reference and stores the common prefixes at the leaves.</p>
<p>The main downside is arguably the unfortunate amount of syntactic noise (for instance, compared to similar linked data structures in Haskell). Still, this is somewhat to be expected in a more low-level programming language - with the clutter comes flexibility.</p>
<p>A very nice side-effect is that in simple cases, as <code>r</code> is not restricted to be matchable (it uses the ordinary function arrow), references can be omitted for known finitely sized structures.</p>
<pre><code class="language-WTy2">x: List(r={it}, t=Int) = Cons(1, Cons(2, Cons(3, Nil)))
</code></pre>
<p>Note this works because the type of <code>x</code> is elaborated with the constraint <code>x ~ Cons(1, Cons(2, Cons(3, Nil)))</code> which fixes the size of <code>x</code>.</p>
<p>In theory, this means lists with constraints that ensure finite length should also be allowed. In practise, compilers may want to try and detect these cases by iterating through potential inhabiting values. If iterating through all potential inhabiting values takes too long, it is likely that the structure is large enough that it would benefit from being heap allocated anyway. Perhaps it could be made possible (via dependent types) to allow the programmer to write proofs that a constraint implies that the size of the type is bounded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proofs"><a class="header" href="#proofs">Proofs</a></h1>
<p>In many dependently typed language, an unfortunate side effect of needing to translate between different constraints is that code must be cluttered with calls to functions that do effectively nothing except prove that some constraint implies another.</p>
<p>WTy2 attempts to separate out the these &quot;proof&quot; functions from the code that requires them through the mechanism of implicit <code>proof</code>s.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-haskell">-- | 'proofDec' is a valid top-level LValue
{- Examples:

proof(x: Nat, y: Nat) &lt;== { x ~ 2 * y }
    : () &lt;== { even(x) }
    = ...

proof: (x: Nat, y: Nat)  &lt;== { x ~ 2 * y }
    -&gt; () &lt;== { even(x) }
    = ...

proof mulTwoImplesEven(x: Nat, y: Nat) &lt;== { x ~ 2 * y }
    : () &lt;== { even(x) }
    = ...

proof mulTwoImplesEven: (x: Nat, y: Nat) &lt;== { x ~ 2 * y }
    -&gt; () &lt;== { even(x) }
    = ...
-}
proofDec :: Parser ProofDec
proofDec = &quot;proof&quot; *&gt; mkProofDec (optional termIdent)
</code></pre>
<p>As well as <code>fun</code>, WTy2 supports another keyword before top-level function declarations: <code>proof</code>. Named <code>proof</code>s can be called just like normal functions. However, their name can optionally be elided.</p>
<h2 id="semantics"><a class="header" href="#semantics">Semantics</a></h2>
<p>In WTy2, if at any point during typechecking, an expression fails to typecheck, then all in-scope <code>proof</code>s are iterated through. For every <code>proof</code>, all in-scope terms are compared against the arguments, and all compatible argument combinations to perform a call of this <code>proof</code> function are iterated through.</p>
<p>For every call of the proof function, immediately before the failing to typecheck expression, a call to the function is introduced, discarding the result, but matching on it to bring any constraints into scope. The expression is then re-typechecked, with these constraints in scope. If it fails again, that function call is removed, and the next one is tried.</p>
<p>If typechecking with any proof call succeeds, then that call to the proof is left in and typechecking proceeds as normal. If all proofs fail, then the type error is outputted as would be expected.</p>
<p>Importantly, proofs are limited to single function calls. If there is a proof that <code>A =&gt; B</code> and a proof that <code>B =&gt; C</code>, and a proof of <code>A =&gt; C</code> is required, the programmer must explicitly write a new proof of <code>A =&gt; C</code>. This is to prevent typechecking from looping.</p>
<pre><code class="language-WTy2">proof(Proof(A)): Proof(B)

proof(Proof(B)): Proof(C)

proof(Proof(A)): Proof(C) = do {
    _: Proof(B) = QED;
    QED
}
</code></pre>
<h2 id="design-note-transitive-closure-of-proofs"><a class="header" href="#design-note-transitive-closure-of-proofs">Design Note: Transitive Closure of Proofs</a></h2>
<p>While needing to write transitive proofs might seem slightly painful, note it is NOT intended that every single possible valid proof function is written. First of all, this is likely impossible (for the same reason typechecking would loop: infinite valid proofs can be obtained starting from a finite number), but also, it is unnecessary! Why prove anything that isn't helpful?</p>
<p>Instead, it is hoped that the WTy2 programmer writes code assuming all obvious implications are known to the typechecker, and then if a type error is encountered, the programmer writes the proof required for that specific error. The nice side-benefit is that now all future times that same error would appear, the in-scope proof is implicitly called.</p>
<h2 id="design-note-provisional-definitions"><a class="header" href="#design-note-provisional-definitions">Design Note: Provisional Definitions</a></h2>
<p>Idris has a feature with a similar goal (that of splitting proofs and code relying on them) known as &quot;Provisional Definitions&quot; https://docs.idris-lang.org/en/latest/tutorial/provisional.html. The main disadvantage is that you do not get the reuse of proofs that comes from WTy2 (i.e: proofs must be specifically named based on the function they are required in).</p>
<p>The obvious benefit here is that the Idris compiler does not have to search through all possible implicit proofs, meaning the impact on typechecking performance is lessened significantly. Right now, it is somewhat unclear how often implicit proofs will be able to be reused, but it is hoped that this will be a quality-of-life benefit for simple programs will be near the scale of much more heavyweight features, say, tactics (the convenience of not needing any explicit user-interaction to satisfy properties like <code>m + n ~ n + m</code>, I think should not be understated).</p>
<h2 id="implementation-note-typechecking-performance"><a class="header" href="#implementation-note-typechecking-performance">Implementation Note: Typechecking Performance</a></h2>
<p>A naive implementation of the above algorithm will have a pretty devastating impact on typechecking performance. Hopefully some good method of pruning the search space can be found. It is also suggested that when proofs are successfully found, that information is cached somehow so on future compilation it does not need to be rediscovered.</p>
<p>Note the process of searching in-scope terms to find something that will allow the program to typecheck is not at all a new idea. Idris, for example, allows for writing explicit &quot;holes&quot; in programs https://docs.idris-lang.org/en/latest/elaboratorReflection/holes.html, where the compiler can automatically search for expressions that fit the desired type signature using functions labelled with <code>#hint</code> pragmas. Compared to this, WTy2 holes are relatively modest: the expressions are limited to single function calls.</p>
<h2 id="implementation-note-runtime-performance"><a class="header" href="#implementation-note-runtime-performance">Implementation Note: Runtime Performance</a></h2>
<p>WTy2 does not assume totality of functions. This includes proofs, and so it is entirely possible for a proof to typecheck, but then at runtime loop infinitely or crash.</p>
<p>For this reason, to preserve safety, running these proofs is unfortunately necessary. Running these proofs can have severe performance impacts however (to the point of changing the time complexity of many algorithms). It is therefore suggested that WTy2 implementations allow compiling with an option that skips over calls to <code>proof</code>s where the values are discarded, assuming totality. This has the result of turning infinite loops/runtime crashes into undefined behaviour.</p>
<h2 id="compiler-warnings"><a class="header" href="#compiler-warnings">Compiler Warnings</a></h2>
<p>Marking a function as a <code>proof</code>s is only useful if it returns proof of a constraint that mentions at least one of the arguments. It is suggested that this property should be checked for (possibly producing a warning) by implementations.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Importing proofs operates similarly to importing type instances: they are implicitly imported from modules.</p>
<p>In fact, proofs can be thought of as somewhat similar to instances: they allow defining implications between one constraint and another. The main difference is arguably that <code>proof</code>s must be justified while <code>instance</code>s are taken as axioms, but for this reason are much more limited (to prevent unsoundness).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-and-the-ex-monad"><a class="header" href="#io-and-the-ex-monad">IO and the Ex Monad</a></h1>
<p>WTy2 is an impure language. Side-effects like printing to the terminal can occur at any time without requiring monads.</p>
<p>However, if values are read from the outside world, they do need to be wrapped in the <code>Ex</code> monad.</p>
<p>The purpose of this is twofold: we make explicit the CPS conversion which allows for efficient monomorphisation, and we get some nice properties like parametricity.</p>
<p>As an explanation on the first point, imagine we have a function <code>readBool() -&gt; Ex(Bool)</code> and then pass the returned integer to functions <code>f</code> and <code>g</code>.</p>
<pre><code class="language-WTy2">x &lt;- readBool();
f(x);
g(x);
</code></pre>
<p>This is transformed into</p>
<pre><code class="language-WTy2">readBool() &gt;&gt;= { f(it); g(it); }
</code></pre>
<p>This allows the compiler to analyse the closure <code>{ f(it); g(it); }</code> and potentially monomorphise it for <code>True</code> and <code>False</code>. This means that if both <code>f</code> and <code>g</code> switch on the boolean, we can compile this into a single switch (without relying on inlining, which while very useful, has limitations with regards to code bloat: if <code>f</code> and <code>g</code> are very large functions, and they were called in many places, it would be much more desirable to compile only two copies of <code>f</code> and <code>g</code> for the <code>True</code> and <code>False</code> cases, instead of a version for every single call).</p>
<p>The <code>Ex</code> monad is used to encourage code of this style, while making it obvious where extra closures are coming from. For example, if we did not have the <code>Ex</code> monad, then it would be very unclear if code like:</p>
<pre><code>x = readBool();
f(x);
g(x);
</code></pre>
<p>was compiled into <code>x = readBool(); { f(it); g(it); }(x)</code> or not.</p>
<h2 id="parametricity"><a class="header" href="#parametricity">Parametricity</a></h2>
<p>With <code>Ex</code>, WTy2 also obeys a weakened form a parametricity. In Haskell, a non-partial function with type signature <code>forall t. t -&gt; t -&gt; t</code> can (in the absense of hacks like <code>unsafePeformIO</code>) only have two implementations (return the first element, or return the second).</p>
<p>In WTy2, a function with type signature <code>[t: Type](a: t, b: t) -&gt; t</code> also can only return the first element or the second, but it may perform other side-effects as well (the return value just cannot be influenced by those side-effects).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-aware-allocators"><a class="header" href="#type-aware-allocators">Type Aware Allocators</a></h1>
<p>A goal of WTy2 is to allow for good performance (especially with regards to memory locality) without much additional work on the part of the programmer/enforcing closed-world assumptions on your code.</p>
<p>A major part of this is the concept of a type-aware-allocator. WTy2 makes extensive use of allocators (array based and recursive data structures in WTy2 should ideally be generic over the allocation scheme) so by providing tools to create good ones, almost all data structures should benefit.</p>
<p>As an example for the sort of properties we would like to achieve, suppose our program had a large list of <code>Int</code>s, this was then upcasted into a list of <code>Num</code>s and then many other opaque <code>Num</code>s got added to the list. We then calculate a total sum. Note that this operation does not care about the order in which we iterate over the values - ideally (for cache and memory locality reasons) we should somehow keep all the <code>Int</code>s in their own region of memory and sum these first.</p>
<p>The rules for performing specialisation with these allocators should use similar (perhaps the same) rules as ordinary function specialisation. i.e: a good heuristic is if we allocate any value with known concrete type, we should specialise for that type.</p>
<p>A potential path for implementation is &quot;indexed variables&quot;:
Syntax WIP, but perhaps something like:</p>
<pre><code class="language-WTy2">strict foo(t :=&gt; Monoid): List(t) = list(100) { mempty(t) }
</code></pre>
<p>Here, <code>foo</code> should be expanded into a number of variable declarations, using the same rules as function specialisation for how many variables to create.</p>
<p>i.e: one valid expansion would be</p>
<pre><code class="language-WTy2">foo_Int: List(Int) = list(100) { mempty(t) };
foo_Monoid: List(Monoid) = list(100) { mempty(t) };
</code></pre>
<p>another is</p>
<pre><code class="language-WTy2">foo_Monoid: List(Monoid) = list(100) { mempty(t) };
</code></pre>
<p>Programs should not rely on a specific number of instances being created.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities"><a class="header" href="#utilities">Utilities</a></h1>
<p>WTy2's syntax is very flexible, which allows for functions to take the role of what are typically built-in language constructs in other languages. Below are a few examples:</p>
<h2 id="do"><a class="header" href="#do">Do</a></h2>
<p>Inspired by Haskell</p>
<pre><code class="language-WTy2">do(f: () -&gt; t): t = f()
</code></pre>
<h2 id="if-else"><a class="header" href="#if-else">If-Else</a></h2>
<pre><code class="language-WTy2">if[t: Type](c: Bool, e: () -&gt; t): Maybe(t) = match(c)
    case(False) = Nothing
    case(True)  = Just(e())
</code></pre>
<pre><code class="language-WTy2">else[t: Type](x: Maybe(t), e: () -&gt; t): t = match(x)
    case(Just(y)) = y
    case(Nothing) = e()
</code></pre>
<h2 id="fun"><a class="header" href="#fun">Fun</a></h2>
<p>Inspired by Kotlin</p>
<pre><code class="language-WTy2">fun[r: Type](t: Type, f: t -&gt; r): t -&gt; r = f
</code></pre>
<h2 id="the"><a class="header" href="#the">The</a></h2>
<p>Inspired by Idris</p>
<pre><code>the(t: Type, x: t): t = x
</code></pre>
<h2 id="with-and-also"><a class="header" href="#with-and-also">With and Also</a></h2>
<p>Inspired by Kotlin</p>
<pre><code class="language-WTy2">with[t: Type, r: Type](x: t, f: t -&gt; r): r = f(x)
</code></pre>
<pre><code class="language-WTy2">also[t: Type](x: t, f: t -&gt; ()): t = do {
    f(x);
    x
}
</code></pre>
<h2 id="design-note-loops"><a class="header" href="#design-note-loops">Design Note: Loops</a></h2>
<p>WTy2 is primarily a functional language and so higher order functions like <code>map</code> are recommended over loop constructs. In fact, the approach for handling side-effects in WTy2 is currently a WIP, and loops are only really useful if side-effects like mutability possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specialisation"><a class="header" href="#specialisation">Specialisation</a></h1>
<p>WTy2 does NOT currently feature &quot;specialisation&quot; as a high-level language feature (à la Rust), being able to override typeclass instances for specific types. Instead, specialisation, in the context of WTy2 refers to an optimisation strategy that is key to get highly polymorphic WTy2 programs to perform well.</p>
<p>Specialisation can be thought of a bit like a &quot;lite&quot; version of monomorphisation. Types can be infinitely large in WTy2, so full monomorphisation as a compilation strategy is infeasible; however, where possible, compiling separate versions of functions for specific argument values (or sets of argument values) and dispatching to those specialised versions can get most of the benefits (the main downside being the compiler now has to decide on a strategy for deciding when to specialise).</p>
<p>Some possible heuristics for deciding when specialisation might be a good idea:</p>
<ul>
<li>A function is explicitly called somewhere in the program with an argument of constant value. For example, if a function takes an arbitrary <code>Num</code> and is called somewhere with the <code>Int</code> literal <code>23</code>, a specialisation for <code>23</code> could be generated.</li>
<li>One of the function's arguments have a small set of inhabiting values. For example, if a function takes a boolean argument, specialisations for when this boolean is true and false would be ideal.</li>
</ul>
<p>Specialisation is similar to inlining, but it means specialised code can be reused, reducing executable bloat. Prioritising specialisation over inlining seems reasonable as a way to not have overly long compilation times.</p>
<h2 id="dispatching-to-specialised-functions"><a class="header" href="#dispatching-to-specialised-functions">Dispatching to Specialised Functions</a></h2>
<p>Dispatching to specialised functions at runtime rather than compile time would greatly increase the power of this feature. i.e: suppose there is a function <code>foo: [n: Num](n) -&gt; n</code> and with a specialisation for <code>n ~ Int</code>. We would like to ensure that even code like <code>x: Int = 0; y: Num = x; z = foo(y);</code> uses the specialiased version of <code>foo</code>, using the type information (in the form of variant tags) that is kept around at runtime to dispatch appropriately. With this guarantee, it would be feasible to actually allow the programmer to specify alternate code paths for specialisations of functions manually (without inconsistency where upcasting and calling results in different behaviour).</p>
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>À la Haskell - https://wiki.haskell.org/Inlining_and_Specialisation#What_is_specialisation.3F</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
