<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The WTy2 Language Specification</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="core_types.html"><strong aria-hidden="true">2.</strong> Core Types</a></li><li class="chapter-item expanded "><a href="declarations.html"><strong aria-hidden="true">3.</strong> Declarations</a></li><li class="chapter-item expanded "><a href="dependent_types.html"><strong aria-hidden="true">4.</strong> Dependent Types</a></li><li class="chapter-item expanded "><a href="erasure_visibility.html"><strong aria-hidden="true">5.</strong> Erasure and Visibility</a></li><li class="chapter-item expanded "><a href="recursive_types.html"><strong aria-hidden="true">6.</strong> Recursive Types</a></li><li class="chapter-item expanded "><a href="proofs.html"><strong aria-hidden="true">7.</strong> Proofs</a></li><li class="chapter-item expanded "><a href="allocators.html"><strong aria-hidden="true">8.</strong> Type Aware Allocators</a></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">9.</strong> Utilities</a></li><li class="chapter-item expanded "><a href="specialisation.html"><strong aria-hidden="true">10.</strong> Specialisation</a></li><li class="chapter-item expanded "><a href="subset.html"><strong aria-hidden="true">11.</strong> Core Subset</a></li><li class="chapter-item expanded "><a href="soundness.html"><strong aria-hidden="true">12.</strong> Soundness</a></li><li class="chapter-item expanded "><a href="arrows.html"><strong aria-hidden="true">13.</strong> Arrows</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">14.</strong> Functions</a></li><li class="chapter-item expanded "><a href="constraints.html"><strong aria-hidden="true">15.</strong> Constraints</a></li><li class="chapter-item expanded "><a href="modes.html"><strong aria-hidden="true">16.</strong> Modes</a></li><li class="chapter-item expanded "><a href="wadlers_law.html"><strong aria-hidden="true">17.</strong> Syntax Debates</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The WTy2 Language Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/WTy-2/spec/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>WTy2 is a dependently typed, functional programming language.</p>
<p>It was designed with a few goals in mind:</p>
<ul>
<li>Aim for there to be exactly one &quot;best&quot; way to design every abstraction. If there has to be multiple, the relative trade-offs for each should be obvious and small in number.</li>
<li>Allow extremely strong compile-time guarantees (via dependent types), but optionally. It should be possible to start with a program that relies heavily on run-time assertions and bit-by-bit introduce more and more static checks without major refactoring.</li>
<li>To support this, breaking from common philosophy on dependent types, WTy2 does NOT encourage creating many separate datatypes to maintain invariants (correct-by-construction). For example, the idiomatic WTy2 encoding a vector (length-indexed list) is to pass a list and a constraint holding a runtime irrelevant proof that it's length is equal to <code>n</code>, NOT to define a new inductive datatype. The style of invariant-capturing WTy2 encourages therefore is more similar to languages with refinement-type systems. To make this feasible in a dependently typed setting, WTy2 introduces a simple but powerful concept of &quot;implicit proofs&quot;.</li>
<li>WTy2 is also designed to be (eventually) <strong>blazing fast</strong>. Implementing the type system will be more than enough work for the forseable future, but to avoid shooting itself in the foot if/when focus shifts to performance, types are unboxed and linear-by-default and an initial design has been sketched out for &quot;type-aware allocators&quot; which would help support performant heterogeneous collections.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-types"><a class="header" href="#core-types">Core Types</a></h1>
<p>WTy2 is a language with subtyping and with first-class types. This has an interesting consequence: instead of having some sort of &quot;kind&quot; system, the key language constructs in WTy2 simply implement various built-in types.</p>
<h2 id="any"><a class="header" href="#any">Any</a></h2>
<p><code>Any</code> is the supertype of all types.</p>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p><code>Type</code> is the supertype of all &quot;types&quot;. This includes anything which can appear on the RHS of a <code>:</code> binding.</p>
<p>An automatic instance of <code>Type</code> is derived for every type declaration.</p>
<h2 id="constraint"><a class="header" href="#constraint">Constraint</a></h2>
<p><code>Constraint</code> represents &quot;constraints&quot;. These can look syntactically similar to bindings (the constraint-versions of binding operators contain an extra <code>:</code> to disambiguate), but instead of bringing variables into scope, they constrain existing values.</p>
<p>Constraints can be created with the built-in <code>~</code>, <code>::</code> and <code>&lt;::</code> operators.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p><code>a -&gt; b</code> is the generic function type. Function arrows in WTy2 are dependent, but to avoid always having to write non-dependent arrows as <code>a -&gt; { b }</code>, WTy2 features some syntax sugar which automatically inserts braces.</p>
<h2 id="tuplesrecordsdependent-pairsliststelescopes"><a class="header" href="#tuplesrecordsdependent-pairsliststelescopes">Tuples/Records/Dependent Pairs/Lists/Telescopes</a></h2>
<p>Yep, Tuples, Records, Dependent Pairs, Lists and Telescopes in WTy2 are all supported via the same built-in datatype (somewhat similarly to how TypeScript supports tuple-like syntax with it's arrays, but in a dependent setting). This datatype and associated sugar in WTy2 becomes a little complicated, and so it has it's own dedicated section in the spec.</p>
<h3 id="unit-"><a class="header" href="#unit-">Unit (&quot;()&quot;)</a></h3>
<p><code>()</code> is the unit tuple. It implements <code>Type</code>, <code>Constraint</code> AND <code>()</code> (i.e: itself)</p>
<h3 id="design-note-singleton-tuples"><a class="header" href="#design-note-singleton-tuples">Design Note: Singleton Tuples</a></h3>
<p>WTy2 also supports singleton tuples. The parsing ambiguity of expression in parens vs a singleton tuple is resolved as follows:
<code>(E)</code> where <code>E</code> is an expression - parenthesised expression
<code>(E,)</code> where <code>E</code> is an expression - singleton tuple
<code>(i: E)</code> where <code>i</code> is an identifier and <code>E</code> is an expression - singleton named tuple</p>
<h3 id="design-note-bindings"><a class="header" href="#design-note-bindings">Design Note: Bindings</a></h3>
<p>In WTy2, the types of records look almost identical to <code>Bind</code>ings. However, <code>Bind</code>ings are NOT first-class. <code>return (x: Int)</code> returns a <code>Type</code> which is equal to the record type <code>(x: Int)</code>. <code>{x: Int}() = 4</code> is not a valid way to bring <code>x</code> into scope.</p>
<h2 id="void"><a class="header" href="#void">Void</a></h2>
<p><code>Void</code> is the subtype of all types. It contains no inhabitants.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declarations"><a class="header" href="#declarations">Declarations</a></h1>
<p>WTy2 supports top-level bindings in the form of &quot;declarations&quot;.</p>
<p>All named declarations can be prefixed with visibility annotations.</p>
<h2 id="type-declarations"><a class="header" href="#type-declarations">Type Declarations</a></h2>
<p>Type declarations define &quot;types&quot;. Note types in WTy2 are quite different from types in many other languages: for instance, types can be open, allowing instances for the type to be made apart from it's declaration.</p>
<p>Note &quot;type&quot;s in WTy2 were originally named &quot;trait&quot;s for this very reason. I have since decided it makes more sense to just call them &quot;type&quot;s because there is no other construct in the language which fits the same role.</p>
<p>Open types can have a number of associated functions that must be defined at instances of that type. In these functions, there is an implicit constant <code>self: Type</code> in scope which refers to the instance head.</p>
<p>Supertypes of the type are optionally explicitly declared after the <code>{}</code>s with <code>=&gt;</code>.</p>
<p>As an example, here is the <code>MonadC</code> type, which is similar to a <code>Monad</code> in functional languages like <code>Haskell</code> but is not total (meaning it can support data structures like sets and hashmaps)</p>
<pre><code class="language-WTy2">type MonadC(c: Type) {

    fmap[a: c, b: c](x: self(a), f: a -&gt; b): self(b)

    pure[a: c](x: a): self(a)

    (&gt;&gt;=)[a: c, b: c](x: self(a), f: a -&gt; self(b)): self(b)

} =&gt; c -&gt; Any
</code></pre>
<p><sup class="footnote-reference"><a href="#note">1</a></sup></p>
<h3 id="type-synonyms"><a class="header" href="#type-synonyms">Type Synonyms</a></h3>
<p>Sometimes a type is desired that is simply a synonym for some other more elaborate type. As types are first class, this can be implemented in WTy2 just with ordinary functions; however, functions have slightly different semantics to distinct types (functions reduce, while types do not) which can impact typechecking and inference.</p>
<p>Type synonyms can be alternatively written by simply declaring a type with the appropriate supertype constraint and then writing a single instance:</p>
<pre><code class="language-WTy2">type Alias {} =&gt; Foo

instance Alias for Foo
</code></pre>
<p>Because this pattern is so common, WTy2 provides syntax sugar for it:</p>
<pre><code>type Alias = Foo
</code></pre>
<p>As coherence rules enforce that instances where the instance head is an open type prevent any other instances being written, it is suggested that ideal practice when writing an open-head instance is to instead write a type alias. Implementations may wish to warn the programmer in scenarios where this is not done.</p>
<h2 id="instance-declarations"><a class="header" href="#instance-declarations">Instance Declarations</a></h2>
<h3 id="coherence-and-orphan-rules"><a class="header" href="#coherence-and-orphan-rules">Coherence and Orphan Rules</a></h3>
<p>It is critical to soundess of the WTy2 language that instances do not overlap. The rules for avioding overlap can be summarised as:</p>
<ul>
<li>If the instance head is open, that instance must be in the same module as the type declaration and no other instances can be written.</li>
<li>If the instance head is closed, either the instance must be in the same module as the type declaration, or all implementing patterns must contain at least one variant tag that was defined in the same module (in other words: it must be impossible to write this instance in some other module without importing the one you are writing the instance in).</li>
</ul>
<h3 id="named-instances"><a class="header" href="#named-instances">Named Instances</a></h3>
<p>WTy2 supports &quot;named instances&quot; as an alternative to the newtype pattern.</p>
<p>The exact semantics and syntax of this feature are WIP, but the goal is to have something at least as powerful as Haskell's &quot;deriving via&quot; extension: enabling overridable default superclass instances.</p>
<h2 id="data-declarations"><a class="header" href="#data-declarations">Data Declarations</a></h2>
<p>Data declarations define &quot;variants&quot;. These appear similar to functions but instead of producing arbitrary values after executing some computation, they create tagged versions of whatever type they are declared to take as parameter.</p>
<p>The suggested implementation is for tags to all share the same 32-bit space of values. As an optimisation, it is suggested that this tag is elided in cases where it is known at compile-time.</p>
<p>I.e: In the below program</p>
<pre><code class="language-WTy2">data Foo(Bar)

x: Bar = ...
y: Foo = Foo(x)
</code></pre>
<p>Both <code>Foo</code> and <code>Bar</code> should have equivalent runtime representations.</p>
<p>Handling variance while ensuring unnecessary tag information is not stored at runtime is not a trivial problem: for how this is solved specifically with regards to recursive types (which is the arguably most awkward one), see the dedicated section.</p>
<h2 id="functionconstant-declarations"><a class="header" href="#functionconstant-declarations">Function/Constant Declarations</a></h2>
<p>Ordinary terms like functions or constants can also be defined as top level bindings. They do not need to be prefixed with any keyword.</p>
<h3 id="proof-declarations"><a class="header" href="#proof-declarations">Proof Declarations</a></h3>
<p>However, functions can be optionally be prefixed with the <code>proof</code> keyword. This changes the semantics of the binding, allowing calls to the function to be inserted automatically to aid typechecking. Proofs my also be anonymous. See the dedicated section on proofs for more information.</p>
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>Note that with function contravariance, we could also have <code>f: c -&gt; b</code> in <code>fmap</code>, and if <code>MonadC</code> itself was contravariant, <code>x: self(c)</code> and then no need for <code>a</code>. WTy2 currently does not support variance due to added complexity, but code like this shows places where it could be very useful.</p>
</div>
<p>Also note the the <code>a: c</code> and <code>b: c</code> constraints here are slightly tiresome. Arguably these could be inferred from their use as arguments to <code>self</code>. There has been some research in Haskell on doing this inference https://richarde.dev/papers/2020/partialdata/partialdata.pdf and it appears to be highly effective in practice (though it is unclear how well it will extend to a language with subtyping).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependent-types"><a class="header" href="#dependent-types">Dependent Types</a></h1>
<p>WTy2 features dependent record and function types.</p>
<h2 id="constrained-by-"><a class="header" href="#constrained-by-">Constrained By <code>(&lt;==)</code></a></h2>
<p>Often, in dependently typed languages, a dependent record only needs to carry evidence of a constraint as the second argument, for the purpose of bringing it into scope as evidence of a predicate. This pattern is made more convenient in WTy2 through the <code>&lt;==</code> operator (read as &quot;constrained by&quot;).</p>
<p>The <code>&lt;==</code>operator has the following type signature:</p>
<pre><code class="language-WTy2">(&lt;==) : (a: Type, f: a -&gt; Constraint) -&gt; Type
</code></pre>
<p>To construct a value of type <code>a &lt;== b</code> from a value <code>x</code> of type <code>a</code>, <code>b(x)</code> must be in the context. Matching on a value of type <code>(x: a) &lt;== b</code> is similar to matching on a value of type <code>a</code>, but <code>b(x)</code> is added to the context.</p>
<p>In use, this operator has similarities to refinement types (i.e: in Liquid Haskell) (i.e: in that the constraint evidence is passed entirely implicitly).</p>
<p>An approximation of this operator in Idris (but for which construction and matching is not implicit) could be defined like so:</p>
<pre><code class="language-idris">Proof : Bool -&gt; Type
Proof p = p = True

data (&lt;==) : (a: Type) -&gt; (p: a -&gt; Bool) -&gt; Type where
  Mk : (x: a) -&gt; (f: Proof (p x)) -&gt; ((&lt;==) a p)

infix 4 &lt;==
</code></pre>
<p>Idris (as far as I am aware) does not have an equivalent of equality coercion constraints like WTy2 (or indeed Haskell) so we are forced to use <code>-&gt; Bool</code> and propositional equality <code>=</code> to represent predicates instead.</p>
<p>An example use would be to restrict the integers received by a function:</p>
<pre><code class="language-idris">total
foo : (Nat &lt;== \x =&gt; 1 &lt;= x &amp;&amp; x &lt;= 3) -&gt; ()
test3 (Mk 1 {f=Refl}) = ()
test3 (Mk 2 {f=Refl}) = ()
test3 (Mk 3 {f=Refl}) = ()
</code></pre>
<p>We can see that although <code>foo</code> only matches on the natural number being <code>1</code>, <code>2</code> or <code>3</code>, the function is still correctly typechecked as <code>total</code>, as we must also pass a proof that the <code>Nat</code> is in the range <code>[1-3]</code>.</p>
<p>The equivalent WTy2 declaration of <code>foo</code> is:</p>
<pre><code class="language-WTy2">foo(x: Nat) &lt;== { 1 &lt;= x &amp;&amp; x &lt;= 3 ~ True }
</code></pre>
<p>This sort of constraint is useful enough that defining a type synonym is probably a good idea.</p>
<pre><code>type NatBetween(min: Nat, max: Nat)
    = Nat &lt;== { min &lt;= it &amp;&amp; it &lt;= max ~ True }

foo(x: NatBetween(1, 3))
</code></pre>
<p>As records can have multiple entries we can easily constrain arguments in terms of another. For example, we can define a function <code>bar</code> which takes two <code>Nat</code>s, <code>x</code> and <code>y</code>, where <code>y</code> must be greater than <code>x</code>:</p>
<pre><code>bar(x: Nat, y: Nat) &lt;== { y &gt; x ~ True }
</code></pre>
<h3 id="design-note-equivalent-constraints"><a class="header" href="#design-note-equivalent-constraints">Design Note: Equivalent Constraints</a></h3>
<p>You may realise that as constraints can contain arbitrary expressions, we could formulate these constraints in many different ways. For example, we could write <code>{ contains([1, 2, 3], it) ~ True }</code>, or even <code>{ max(1, min(3, it)) ~ it }</code>. That these constraints do indeed imply each other though, is not always obvious (expecially to the typechecker).</p>
<p>This is arguably the main pain-point with dependent types - proving that one constraint implies another can be tiresome and clutter up code significantly. WTy2 attempts to make this slightly less painful through the ability to write implicit <code>proof</code>s.</p>
<h2 id="dependent-function-arrow"><a class="header" href="#dependent-function-arrow">Dependent Function Arrow</a></h2>
<p>WTy2 also supports dependent function arrows, through a similar mechanism. The argument record to a function is in scope in the return type (including the return constraint), as well as the function body.</p>
<p>Note this makes <code>&lt;==</code> constraints on return types somewhat ambiguous in that if the return type of the function is a record with identically named fields (or simply the <code>it</code> keyword is used), this could refer to the argument record or the return. WTy2 disambiguates this by treating this case as shadowing. In general, the innermost <code>it</code> (and it's associated record names) shadow the outermost one.</p>
<p>Currently, there is no mechanism to forcefully disambiguate (though perhaps some syntax to specify de Bruijn indices or similar could work). The field names of the argument or return record must be changed to refer to the argument record fields in the return constraint.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erasure-and-visibility"><a class="header" href="#erasure-and-visibility">Erasure and Visibility</a></h1>
<h1 id="runtime-relevance-of-types-and-constraints"><a class="header" href="#runtime-relevance-of-types-and-constraints">Runtime Relevance of Types and Constraints</a></h1>
<p>In Haskell, runtime relevance can effectively be summarised as: types are erased, constraints are not. Even equality constraints like <code>a ~ b</code> which don't contain any fields often do not get fully optimised away as <code>Constraint</code> is lifted and so could point to a bottoming value (see discussion at https://github.com/ghc-proposals/ghc-proposals/pull/547).</p>
<p>In WTy2, we take the opposite approach: constraints are erased but types are not. To perform dispatch, implementations will in all likelyhood need to implement some sort of runtime.</p>
<h1 id="erasure-and-visibility-in-types-and-values"><a class="header" href="#erasure-and-visibility-in-types-and-values">Erasure and Visibility in Types and Values</a></h1>
<p>Even though values and types must in general be kept around at runtime, in many specific cases, this is not necessary (consider a generic function which takes both a type <code>t :|=&gt; Animal</code> and an argument <code>a: t</code> - <code>t</code> can be recovered entirely from <code>a</code>). The key observation made here is that arguments we would like the typechecker infer for convenience generally correspond with ones recover.</p>
<p>A type surrounded in parenthesis can be prefixed with something that looks similar to a record type but the bindings are placed inside brackets (<code>[]</code>) instead of parenthesis.</p>
<p>A variable can be bound in the erased elements of a record only if:</p>
<ul>
<li>It occurs by itself in a matchable function application (i.e: as an argument or the function itself) to the right of a member constraint and the type (i.e: RHS object of member constraint) is <code>Closed</code> (the <code>Closed</code> constraint is inferred if the use of <code>[]</code>s require it, similar to definedness constraints which arise from function applications in types). <sup class="footnote-reference"><a href="#note">1</a></sup></li>
<li>It is on the RHS of an equality constraint with a non-erased element (unclear if this is actually useful).</li>
</ul>
<p>An example of erasure being useful is when working with length-indexed vectors:</p>
<pre><code class="language-WTy2">vecLen[t: Type, n: Nat](v: Vec(t, n)): Nat &lt;&lt;= { it ~ n }

returnsVecOfUnknownLen(...): [n: Nat] Vec[Bool, n]
</code></pre>
<p>In <code>vecLen</code>, binding <code>t</code> and <code>n</code> in the <code>[]</code>s allows them to be inferred, and makes it so there is no runtime cost of having to pass the type or length. Note if we had to pass the length explicitly, then the function would be entirely useless: we would need to know the length to calculate it!</p>
<p>This combines nicely with functions like <code>returnsVecOfUnknownLen</code>. If we ever do actually need to know the length (perhaps to pattern match on it), then we can call <code>vecLen</code> on the result, and this all works out because we still have an erased <code>n: Nat</code> in scope.</p>
<p>To be concrete, a term being erased means that it cannot be pattern matched on, or passed as an argument to somewhere where a non-erased term is expected.</p>
<p>Unlike constraints in <code>&lt;&lt;=</code>, erased terms in records can be manually specified at construction or bound when matching.</p>
<pre><code class="language-WTy2">[erasedLen=n] vec = returnsVecOfUnknownLen(...);
len = vecLen[Bool, erasedLen](vec);

// From the signature of 'vecLen', `erasedLen ~ len` is in the context
_: () &lt;&lt;= { erasedLen ~ len } = ();
</code></pre>
<h2 id="bidirectional-type-inference"><a class="header" href="#bidirectional-type-inference">Bidirectional Type Inference</a></h2>
<p>One unfortunate consequence of handling inference in this way is that setting up constraints based on the desired return type (bidirectional type inference) is not really possible. This can be a useful feature - for example, in languages like Haskell, numeric expressions can stay entirely in terms of <code>Num a =&gt; a</code> until finally being instantiated to a specific numeric type at call-site, but it also leads to many cases of potential ambiguity and arguably makes code harder to reason about.</p>
<p><sup class="footnote-reference"><a href="#note">1</a></sup> Note this is less restrictive than it might initially sound. If we have <code>x: Animal</code> and a function <code>id[t: Type](x: t): t</code>, <code>id(x)</code> does indeed typecheck, with <code>t</code> instantiated to <code>x.head(Animal)</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursive-data-types"><a class="header" href="#recursive-data-types">Recursive Data Types</a></h1>
<p>Elsewhere in this spec (I may go back and fix it up later), I have been relatively loose with defining types like:</p>
<pre><code class="language-WTy2">data Cons(head: t, tail: List(t))
data Nil

type List(t: Type) = [head: t, tail: List(t)]
                     Is(Cons(head, tail))
                   | Is(Nil)
</code></pre>
<p>Unfortunately, there is a bit of an issue with values of this type - they have unbounded size! Specifically, if a function takes a <code>List(Int)</code>, the actual list it could receive when called could contain any number of <code>Cons</code> nodes.</p>
<p>Furthermore, it is not clear how to implement variance for this type. If we have a <code>List(Int)</code>, then ideally at each node we would not store any information informing us that the item is indeed an <code>Int</code> (we can know that it could be nothing else from the type signature). However, we would like to be able to pass this into functions accepting say <code>List(Num)</code>. This would seemingly require creating an entirely new list with the <code>Int</code> tag attached to every node.</p>
<p>One potential solution is to simply not use recursive data types. An array list-based data structure would help to avoid these problems and would also provide great memory locality. In functional languages like Haskell and Closure, however, the utility of being able to create large linked structures that utilise sharing cannot really be understated. WTy2 should be able to achieve something similar.</p>
<p>The solution is references, but with perhaps a slightly different flavour to what you might imagine coming from languages like Rust.</p>
<pre><code class="language-WTy2">data Cons[r: Ref](head: t, tail: List(r, t))
data Nil
type List(r: Ref, t: Type) = r(
    [head, tail: List(r, t)] Is(Cons(head, tail))
                           | Is(Nil)
    )
</code></pre>
<p>The main interesting thing about this definition is that <code>r</code>, the type variable that will be instantiated to some sort of reference that will break up the infinite structure, is generic. We could instantiate <code>r</code> to some owning reference type like <code>Box</code> and get a definition similar to what we would achieve in Rust, but we can also do better.</p>
<p>The problem with <code>Box</code> or any other global allocator is poor memory locality. If the elements are added to the list randomly over time, then they will be placed in effectively random locations in memory. What we would like is for every element of the same list (not just same type!) to be placed in more-or-less the same location (note this idea is similar to that of arenas in Rust).</p>
<pre><code class="language-WTy2">type Alloc = ...
type RefTo(a: Alloc, t: Type) = ...

// Get the allocator of a reference
allocOf[a: Alloc, t: Type](r: RefTo(a, t)): Alloc &lt;== { it ~ a }

// Would be a method of the 'Alloc' type
alloc(a: Alloc, t: Type): RefTo(a, t)

// Create a new allocator and allocate an expression using it
new[t](x: t): [a] RefTo(a, t)

// Function application, but wrap in the allocator at the end
build[a: Alloc, t: Type](x: RefTo(a, t), f: RefTo(a, t) -&gt; t)
    : RefTo(a, t) = alloc(allocOf(x), f(x))

// We take advantage of partial signatures to not need to specify the allocator
// in the signatures of 'x' or 'y'
x: List(t=Int) = new(Nil)
y: List(t=Int) = build(x) { Cons(3, it) }


// Alternate style, arguably neater but requires some extra busywork

type ConsLike(r, t) = [head: t, tail: List(r, t)] Is(Cons(head, tail))

// Would likely be a method of some type
// '(,..)' denotes partial application
// (i.e: will fill in the other arguments later)
allocOfCons[a: Alloc, r: RefTo(a,..), t: Type]
    (x: ConsLike(r, t)): Alloc &lt;== { it ~ a  }
    = match(x) case(Cons(_, tail)) -&gt; allocOf(tail)


altBuild[a: Alloc, r: RefTo(a,..), t: Type]
    (x: ConsLike(r, t)): List(r, t)
    = alloc(allocOfCons(x), x)


z: List(t=Int) = altBuild(Cons(3, x))
</code></pre>
<p>There are some interesting consequences of enforcing code like this. For example, if you have two different lists, potentially created with different allocators, the elements from one allocator must be all copied into the other. Because of this, it is recommended that if an algorithm involves a lot of merging of linked data structures, there a single allocator is created at the start and all sub-structures are built up with it.</p>
<p>Note that having the allocator responsible for storing all nodes also helps with the variance problem as mentioned above. Allocators in WTy2 must provide a way of recovering full type information for every value that is stored by them, but to ensure memory is not wasted, a good allocator would store elements with common type prefixes together and avoid duplicating said prefix. The exact mechanism for how these prefixes are represented is WIP and would be dependent on the allocator in question, but one could imagine, for instance, a binary tree which is traversed based on the reference and stores the common prefixes at the leaves.</p>
<p>The main downside is arguably the unfortunate amount of syntactic noise (for instance, compared to similar linked data structures in Haskell). Still, this is somewhat to be expected in a more low-level programming language - with the clutter comes flexibility.</p>
<p>A very nice side-effect is that in simple cases, as <code>r</code> is not restricted to be matchable (it uses the ordinary function arrow), references can be omitted for known finitely sized structures.</p>
<pre><code class="language-WTy2">x: List(r={it}, t=Int) = Cons(1, Cons(2, Cons(3, Nil)))
</code></pre>
<p>Note this works because the type of <code>x</code> is elaborated with the constraint <code>x ~ Cons(1, Cons(2, Cons(3, Nil)))</code> which fixes the size of <code>x</code>.</p>
<p>In theory, this means lists with constraints that ensure finite length should also be allowed. In practise, compilers may want to try and detect these cases by iterating through potential inhabiting values. If iterating through all potential inhabiting values takes too long, it is likely that the structure is large enough that it would benefit from being heap allocated anyway. Perhaps it could be made possible (via dependent types) to allow the programmer to write proofs that a constraint implies that the size of the type is bounded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proofs"><a class="header" href="#proofs">Proofs</a></h1>
<p>In many dependently typed language, an unfortunate side effect of needing to translate between different constraints is that code must be cluttered with calls to functions that do effectively nothing except prove that some constraint implies another.</p>
<p>WTy2 attempts to separate out the these &quot;proof&quot; functions from the code that requires them through the mechanism of implicit <code>proof</code>s.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-haskell">-- | 'proofDec' is a valid top-level LValue
{- Examples:

proof(x: Nat, y: Nat) &lt;== { x ~ 2 * y }
    : () &lt;== { even(x) }
    = ...

proof: (x: Nat, y: Nat)  &lt;== { x ~ 2 * y }
    -&gt; () &lt;== { even(x) }
    = ...

proof mulTwoImplesEven(x: Nat, y: Nat) &lt;== { x ~ 2 * y }
    : () &lt;== { even(x) }
    = ...

proof mulTwoImplesEven: (x: Nat, y: Nat) &lt;== { x ~ 2 * y }
    -&gt; () &lt;== { even(x) }
    = ...
-}
proofDec :: Parser ProofDec
proofDec = &quot;proof&quot; *&gt; mkProofDec (optional termIdent)
</code></pre>
<p>As well as <code>fun</code>, WTy2 supports another keyword before top-level function declarations: <code>proof</code>. Named <code>proof</code>s can be called just like normal functions. However, their name can optionally be elided.</p>
<h2 id="semantics"><a class="header" href="#semantics">Semantics</a></h2>
<p>In WTy2, if at any point during typechecking, an expression fails to typecheck, then all in-scope <code>proof</code>s are iterated through. For every <code>proof</code>, all in-scope terms are compared against the arguments, and all compatible argument combinations to perform a call of this <code>proof</code> function are iterated through.</p>
<p>For every call of the proof function, immediately before the failing to typecheck expression, a call to the function is introduced, discarding the result, but matching on it to bring any constraints into scope. The expression is then re-typechecked, with these constraints in scope. If it fails again, that function call is removed, and the next one is tried.</p>
<p>If typechecking with any proof call succeeds, then that call to the proof is left in and typechecking proceeds as normal. If all proofs fail, then the type error is outputted as would be expected.</p>
<p>Importantly, proofs are limited to single function calls. If there is a proof that <code>A =&gt; B</code> and a proof that <code>B =&gt; C</code>, and a proof of <code>A =&gt; C</code> is required, the programmer must explicitly write a new proof of <code>A =&gt; C</code>. This is to prevent typechecking from looping.</p>
<pre><code class="language-WTy2">proof(Proof(A)): Proof(B)

proof(Proof(B)): Proof(C)

proof(Proof(A)): Proof(C) = do {
    _: Proof(B) = QED;
    QED
}
</code></pre>
<h2 id="design-note-transitive-closure-of-proofs"><a class="header" href="#design-note-transitive-closure-of-proofs">Design Note: Transitive Closure of Proofs</a></h2>
<p>While needing to write transitive proofs might seem slightly painful, note it is NOT intended that every single possible valid proof function is written. First of all, this is likely impossible (for the same reason typechecking would loop: infinite valid proofs can be obtained starting from a finite number), but also, it is unnecessary! Why prove anything that isn't helpful?</p>
<p>Instead, it is hoped that the WTy2 programmer writes code assuming all obvious implications are known to the typechecker, and then if a type error is encountered, the programmer writes the proof required for that specific error. The nice side-benefit is that now all future times that same error would appear, the in-scope proof is implicitly called.</p>
<h2 id="design-note-provisional-definitions"><a class="header" href="#design-note-provisional-definitions">Design Note: Provisional Definitions</a></h2>
<p>Idris has a feature with a similar goal (that of splitting proofs and code relying on them) known as &quot;Provisional Definitions&quot; https://docs.idris-lang.org/en/latest/tutorial/provisional.html. The main disadvantage is that you do not get the reuse of proofs that comes from WTy2 (i.e: proofs must be specifically named based on the function they are required in).</p>
<p>The obvious benefit here is that the Idris compiler does not have to search through all possible implicit proofs, meaning the impact on typechecking performance is lessened significantly. Right now, it is somewhat unclear how often implicit proofs will be able to be reused, but it is hoped that this will be a quality-of-life benefit for simple programs will be near the scale of much more heavyweight features, say, tactics (the convenience of not needing any explicit user-interaction to satisfy properties like <code>m + n ~ n + m</code>, I think should not be understated).</p>
<h2 id="implementation-note-typechecking-performance"><a class="header" href="#implementation-note-typechecking-performance">Implementation Note: Typechecking Performance</a></h2>
<p>A naive implementation of the above algorithm will have a pretty devastating impact on typechecking performance. Hopefully some good method of pruning the search space can be found. It is also suggested that when proofs are successfully found, that information is cached somehow so on future compilation it does not need to be rediscovered.</p>
<p>Note the process of searching in-scope terms to find something that will allow the program to typecheck is not at all a new idea. Idris, for example, allows for writing explicit &quot;holes&quot; in programs https://docs.idris-lang.org/en/latest/elaboratorReflection/holes.html, where the compiler can automatically search for expressions that fit the desired type signature using functions labelled with <code>#hint</code> pragmas. Compared to this, WTy2 holes are relatively modest: the expressions are limited to single function calls.</p>
<h2 id="implementation-note-runtime-performance"><a class="header" href="#implementation-note-runtime-performance">Implementation Note: Runtime Performance</a></h2>
<p>WTy2 does not assume totality of functions. This includes proofs, and so it is entirely possible for a proof to typecheck, but then at runtime loop infinitely or crash.</p>
<p>For this reason, to preserve safety, running these proofs is unfortunately necessary. Running these proofs can have severe performance impacts however (to the point of changing the time complexity of many algorithms). It is therefore suggested that WTy2 implementations allow compiling with an option that skips over calls to <code>proof</code>s where the values are discarded, assuming totality. This has the result of turning infinite loops/runtime crashes into undefined behaviour.</p>
<h2 id="compiler-warnings"><a class="header" href="#compiler-warnings">Compiler Warnings</a></h2>
<p>Marking a function as a <code>proof</code>s is only useful if it returns proof of a constraint that mentions at least one of the arguments. It is suggested that this property should be checked for (possibly producing a warning) by implementations.</p>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Importing proofs operates similarly to importing type instances: they are implicitly imported from modules.</p>
<p>In fact, proofs can be thought of as somewhat similar to instances: they allow defining implications between one constraint and another. The main difference is arguably that <code>proof</code>s must be justified while <code>instance</code>s are taken as axioms, but for this reason are much more limited (to prevent unsoundness).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-aware-allocators"><a class="header" href="#type-aware-allocators">Type Aware Allocators</a></h1>
<p>A goal of WTy2 is to allow for good performance (especially with regards to memory locality) without much additional work on the part of the programmer/enforcing closed-world assumptions on your code.</p>
<p>A major part of this is the concept of a type-aware-allocator. WTy2 makes extensive use of allocators (array based and recursive data structures in WTy2 should ideally be generic over the allocation scheme) so by providing tools to create good ones, almost all data structures should benefit.</p>
<p>As an example for the sort of properties we would like to achieve, suppose our program had a large list of <code>Int</code>s, this was then upcasted into a list of <code>Num</code>s and then many other opaque <code>Num</code>s got added to the list. We then calculate a total sum. Note that this operation does not care about the order in which we iterate over the values - ideally (for cache and memory locality reasons) we should somehow keep all the <code>Int</code>s in their own region of memory and sum these first.</p>
<p>The rules for performing specialisation with these allocators should use similar (perhaps the same) rules as ordinary function specialisation. i.e: a good heuristic is if we allocate any value with known concrete type, we should specialise for that type.</p>
<p>A potential path for implementation is &quot;indexed variables&quot;:
Syntax WIP, but perhaps something like:</p>
<pre><code class="language-WTy2">strict foo(t :=&gt; Monoid): List(t) = list(100) { mempty(t) }
</code></pre>
<p>Here, <code>foo</code> should be expanded into a number of variable declarations, using the same rules as function specialisation for how many variables to create.</p>
<p>i.e: one valid expansion would be</p>
<pre><code class="language-WTy2">foo_Int: List(Int) = list(100) { mempty(t) };
foo_Monoid: List(Monoid) = list(100) { mempty(t) };
</code></pre>
<p>another is</p>
<pre><code class="language-WTy2">foo_Monoid: List(Monoid) = list(100) { mempty(t) };
</code></pre>
<p>Programs should not rely on a specific number of instances being created.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities"><a class="header" href="#utilities">Utilities</a></h1>
<p>WTy2's syntax is designed for allowing defining functions that appear similar to built-in language constructsof other languages. Below are a few examples:</p>
<h2 id="do"><a class="header" href="#do">Do</a></h2>
<p>Inspired by Haskell</p>
<pre><code class="language-WTy2">do(f: () -&gt; t): t = f()
</code></pre>
<p>This is primarily useful when defining functions in <code>f(x: t): u = ...</code>-style where you still want to use a block to define locals or use <code>do</code>-notation sugar <sup class="footnote-reference"><a href="#note">1</a></sup>. E.g:</p>
<pre><code class="language-WTy2">foo(x: Int, y: Int): Int = do {
    z = x * 3;
    w = y - 2;
    (z * z + w) / (x + w)
}
</code></pre>
<h2 id="if-elif-else"><a class="header" href="#if-elif-else">If-Elif-Else</a></h2>
<p>Inspired by oh-so-many programming languages, maybe Algol 58 was first?</p>
<pre><code class="language-WTy2">if[t: Type](c: Bool, e: () -&gt; t): Maybe(t) = with(c) {
| True  -&gt; Just(e()),
| False -&gt; Nothing
}
</code></pre>
<pre><code>elif[t: Type](x: Maybe(t), c: Bool, e: () -&gt; t): Maybe(t) = with(x, c) {
| (Just(y), _) -&gt; x,
| (Nothing, True) -&gt; Just(e()),
| (Nothing, False) -&gt; Nothing,
}
</code></pre>
<pre><code class="language-WTy2">else[t: Type](x: Maybe(t), e: () -&gt; t): t = with(x) {
| Just(y) -&gt; y,
| Nothing -&gt; e()
}
</code></pre>
<p>E.g:</p>
<pre><code class="language-WTy2">if(True) {
    &quot;Case one!&quot;
}.elif(False) {
    &quot;Case two!&quot;
}.else {
    &quot;Case three!&quot;
}
```

## Fun

Inspired by Kotlin

```WTy2
fun[r: Type](t: Type, f: t -&gt; r): t -&gt; r = f
</code></pre>
<p>In WTy2, serves to annotate the argument type of a function without having to use arrow-lambda syntax.</p>
<h2 id="lazy"><a class="header" href="#lazy">Lazy</a></h2>
<p>Inspired by Scala</p>
<pre><code class="language-WTy2">lazy[t: Type](f: () -&gt; t): () -&gt; t = f
</code></pre>
<p>Note this does not perform any memoisation (call-by-need). This would require some form of mutability to implement.</p>
<h2 id="the"><a class="header" href="#the">The</a></h2>
<p>Inspired by Idris</p>
<pre><code>the(x: t, t: Type): t = x
</code></pre>
<p>Annotates the type of <code>x</code>.</p>
<h2 id="with-and-also"><a class="header" href="#with-and-also">With and Also</a></h2>
<p>Inspired by Kotlin</p>
<pre><code class="language-WTy2">with[t: Type, r: Type](x: t, f: t -&gt; r): r = f(x)
</code></pre>
<pre><code class="language-WTy2">also[t: Type, m: Applicative](x: t, f: t -&gt; m()): m(t) = f(x) $&gt; x
</code></pre>
<p><code>with</code> fits really well with lambda-case syntax as a way to pattern match on a variable. E.g:</p>
<pre><code class="language-WTy2">with(x) {
| 0 -&gt; &quot;Zero!&quot;,
| 1 -&gt; &quot;One!&quot;,
| _ -&gt; &quot;Other!&quot;
}
</code></pre>
<p><sup class="footnote-reference"><a href="#note">1</a></sup> Of course in WTy2, <code>do</code>-notation is not really related to the <code>do</code> utility defined here; it can be used in any block... But hey, I didn't name it!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specialisation"><a class="header" href="#specialisation">Specialisation</a></h1>
<p>WTy2 does NOT currently feature &quot;specialisation&quot; as a high-level language feature (à la Rust <sup class="footnote-reference"><a href="#note">1</a></sup>), being able to override typeclass instances for specific types. Instead, specialisation in the context of WTy2 refers to an optimisation strategy that is key to get highly polymorphic WTy2 programs to perform well <sup class="footnote-reference"><a href="#note">1</a></sup>.</p>
<p>Specialisation can be thought of a bit like a &quot;lite&quot; version of monomorphisation. Types can be infinitely large in WTy2, so full monomorphisation as a compilation strategy is infeasible; however, where possible, compiling separate versions of functions for specific argument values (or sets of argument values) and dispatching to those specialised versions can get most of the benefits (the main downside being the compiler now has to decide on a strategy for deciding when to specialise).</p>
<p>Some possible heuristics for deciding when specialisation might be a good idea are:</p>
<ul>
<li>A function is explicitly called somewhere in the program with an argument of more constrained type than the function accepts. For example, if a function takes an arbitrary <code>Num</code> and is called somewhere with and <code>Int</code>, a specialisation <code>Int</code>s should probably be generated. If the function is called with a constant <code>23</code>, then a specialisation for this exact integer could be generated (and likely later inlined, but more on that later).</li>
<li>Note after one function is specialised, function calls in that function's body may now also become candidates for specialisation by the rule above. This transitive specialisation is very powerful, as it can eliminate would might otherwise by a large number of repeated switches.</li>
<li>One of the function's arguments have a small set of inhabiting values. For example, if a function takes a boolean argument, specialisations for when the boolean is true and false might be a good idea.</li>
</ul>
<p>Specialisation is similar to inlining, but generated specialised code can be reused, reducing executable bloat. Prioritising specialisation over inlining seems reasonable as an approach to not have overly long compilation times.</p>
<h2 id="dispatching-to-specialised-functions"><a class="header" href="#dispatching-to-specialised-functions">Dispatching to Specialised Functions</a></h2>
<p>Dispatching to specialised functions at runtime rather than compile time would greatly increase the power of this optimisation. i.e: suppose there is a function <code>foo: [n &lt;: Num](n) -&gt; n</code> and with a much faster specialisation for <code>n ~ Int</code>. We would like to ensure that even code like <code>x: Int = 0; y: Num = x; z = foo(y);</code> uses the specialiased version of <code>foo</code>, using the type information (in the form of variant tags) that is kept around at runtime to dispatch appropriately (assuming the savings from running the specialised version are worth it over the cost of dispatching appropriately). Exactly how feasible this is will likely have to be reassessed after the design for open types/intsances is finalised.</p>
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>The writer of the specification personally considers this form of specialisation as a misfeature and so would be hesitent to work on it, even if there was a feasible implementation strategy for it in WTy2.
<sup class="footnote-reference"><a href="#note">1</a></sup>: À la Haskell - https://wiki.haskell.org/Inlining_and_Specialisation#What_is_specialisation.3F</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-language"><a class="header" href="#core-language">Core Language</a></h1>
<p>Implementing a typechecker and compiler for the entire WTy2 language at once is likely to prove somewhat challenging. Here, a design for an intermediate, typed core language (inspired by efforts on GHC) is outlined.</p>
<p>Core-Lang Constructs:</p>
<ul>
<li>Lambda case expressions (covers lambdas, matches and let bindings)</li>
<li>Telescopes: A single built-in datatype covering (dependent) tuples and lists</li>
<li>Dependent function arrows</li>
<li>Constraints (equality coercions, type membership, quantified constraints)</li>
<li>Data declarations</li>
<li>Type declarations, with associated methods and supertype constraints</li>
<li>Default instance declarations</li>
</ul>
<p>Desugaring:</p>
<ul>
<li>WTy2 core does not feature named tuples/records. These are instead desugared into telescopes like ordinary tuples and lists.</li>
<li>In WTy2 core, all function arrows are dependent, meaning a function that takes and returns an integer would be represented as <code>Int -&gt; { Int }</code></li>
</ul>
<p>Unanswered Questions:</p>
<ul>
<li>How to represent recursion? Could either use recursive binders or a dedicated fixpoint operator.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="soundness"><a class="header" href="#soundness">Soundness</a></h1>
<p>WTy2 claims is a programming language with dependent types first and foremost, NOT a theorem prover.</p>
<p>In fact, WTy2 as it currently exists is highly inconsistent, it is easy to prove bottom and from there anything. The only guarantee making this somewhat palatable is that these are all cases where the program will loop at runtime. WTy2 (when programs are ran in debug mode) will never actually create values of bottom type.</p>
<p>This is useful for programming (proving termination is tiresome and sometimes even impossible) but makes WTy2 effectively useless for theorem proving. In the far future if these holes were to be closed (probably with some sort of compiler flag, <code>safe</code>), then this would no longer be the case, and hence these holes are documented below:</p>
<h2 id="non-termination-recursion"><a class="header" href="#non-termination-recursion">Non-termination Recursion</a></h2>
<pre><code class="language-WTy2">foo() = foo()
</code></pre>
<h2 id="russels-paradox---danger"><a class="header" href="#russels-paradox---danger">Russel's Paradox - DANGER!!</a></h2>
<p>WTy2's type system implemented naively, due to subtyping, does not prevent
types being members of themselves. This can lead to Russel style paradoxes.</p>
<pre><code class="language-WTy2">-- `t =&gt; Void` is equivalent to `t @ t ==&gt; t @ Void`
type Russel = (t: Type) &lt;== { t =&gt; Void }

ohDear(): Void {
    _: Proof(Russel: Russel) = QED;
    _: Proof(Russel: Void) = QED;
    Russel
}
</code></pre>
<p>The constraint solver would attempt to solve this like so:</p>
<pre><code class="language-WTy2CoSo">[G1] (Russel(t), t(t)) ==&gt; Void(t)
[G2] (t(t) ==&gt; Void(t)) ==&gt; Russel(t)

[W1] Russel : Russel

# Head of G2 matches, instantiate LHS with t=Russel

[W2] Russel(Russel) ==&gt; Void(Russel)

# Wanted is an implication, so assume LHS

[G3] Russel(Russel)

[W3] Void(Russel)

# Head of G1 matches, instantiate LHS with t=Russel

[W4] (Russel(Russel), Russel(Russel))

# Solve trivially via G3
</code></pre>
<p>So can conclude <code>Russel : Russel</code>
Oh dear!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrows"><a class="header" href="#arrows">Arrows</a></h1>
<p>WTy2 has a lot of arrows, they are summarised here.</p>
<h2 id="function--"><a class="header" href="#function--">Function (-&gt;)</a></h2>
<pre><code class="language-WTy2">(-&gt;): (Type, Type) -&gt; Type
</code></pre>
<p>Ordinary function arrow.</p>
<h2 id="constructor-"><a class="header" href="#constructor-">Constructor (~&gt;)</a></h2>
<pre><code class="language-WTy2">(~&gt;): (Type, Type) -&gt; Type
</code></pre>
<p>Similar to function arrow, but must be &quot;matchable&quot;. i.e: <code>(x: a, y: a, f: a -&gt; b, g: a -&gt; b) &lt;&lt;= f(x) ~ g(y) |- f ~ g /\ a ~ b</code> is in scope.</p>
<h2 id="constrained-by--1"><a class="header" href="#constrained-by--1">Constrained By (&lt;&lt;=)</a></h2>
<pre><code class="language-WTy2">(&lt;&lt;=): (t: Type, p: t -&gt; Constraint) -&gt; Type
</code></pre>
<p>Narrows a type, requiring the constraint to be true on the value for it to a member of the new type. When pattern matching on members of the type, the constraint is brought into scope.</p>
<h2 id="supertype-"><a class="header" href="#supertype-">Supertype (&lt;:)</a></h2>
<pre><code class="language-WTy2">(&lt;:): (Type, Type) -&gt; Constraint
</code></pre>
<p>Values of the LHS type can be upcast into ones of the RHS type.</p>
<h2 id="implies-"><a class="header" href="#implies-">Implies (=&gt;)</a></h2>
<pre><code class="language-WTy2">(=&gt;): (Constraint, Constraint) -&gt; Constraint
</code></pre>
<p>The RHS constraint can be obtained from the LHS constraint.</p>
<h2 id="entails--"><a class="header" href="#entails--">Entails (|-)</a></h2>
<pre><code class="language-WTy2">(|-): (Type, Constraint) -&gt; Type
a |- r = a -&gt; Proof(r)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>Functions in WTy2 can be created with function declarations or lambda.</p>
<h2 id="lambda-blocks"><a class="header" href="#lambda-blocks">Lambda-Blocks</a></h2>
<p>In WTy2, braces (<code>{}</code>) are used to denote a lambda. Inside the braces, there can be:</p>
<ul>
<li>Just an expression. In this case the argument type is inferred, and can be referred to in the expression as <code>it</code>. The really powerful part here is that variables <code>varName</code> are attempted to be resolved as fields of <code>it</code> first (as in <code>it.varName</code>). This is similar to <code>this</code> being in scope allowing access to fields and methods of the class without needing to specify the receiver in OOP languages.</li>
<li>A &quot;<code>\</code>&quot; followed by an irrefutable pattern which is bound to by the argument, an <code>-&gt;</code> and the return expression.</li>
<li>Multiple <code>|</code>s, each followed by a pattern, a <code>-&gt;</code> and a return expression for if that match succeeds.</li>
</ul>
<h2 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h2>
<p>WTy2 is a functional programming language, meaning functions are first class and can be bound to variables. Using only existing introduced syntax, a function that adds three integers can be defined like so:</p>
<pre><code class="language-wty2">addThree: (Int, Int, Int) -&gt; Int = { \(x, y, z) -&gt; x + y + z };
</code></pre>
<p>Using record syntax, we can achieve this in a slightly cleaner way as</p>
<pre><code class="language-wty2">addThree: (x: Int, y: Int, z: Int) -&gt; Int = { x + y + z };
</code></pre>
<p>WTy2 introduces an additional way to define functions, which looks closer to imperative programming languages:</p>
<pre><code class="language-wty2">addThree(x: Int, y: Int, z: Int): Int = x + y + z;
</code></pre>
<p>In general <code>f(t): u</code> can be used anywhere <code>f: t -&gt; u</code> would also fit, with one small difference. If it is the LHS of an assignment (like above, then the braces around the RHS expression are implicit).</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>In WTy2, the source syntax allows functions to recursively call themselves or others defined in the same scope freely, making this simple for the programmer.</p>
<p>Functions in WTy2 are both unboxed and capturing by default, so implementing recursion is not quite as simple as one might assume. Consider in Rust how closures cannot refer to themselves. This can be worked around with a few patterns, such as creating a non-capturing recursive <code>fn</code> item inside the closure and passing in the enviroment, but this is quite clunky.</p>
<pre><code class="language-rs">let step = 1;
let foo = |x| {
    fn foo_rec(step: i32, x: i32) -&gt; i32 {
        if (x &lt;= 0) { 0 } else { x + foo_rec(step, x-step) }
    }
    foo_rec(step, x)
};
println!(&quot;{}&quot;, foo(10));
</code></pre>
<p>In WTy2, the source syntax allows functions to recursively call themselves or others defined in the same scope freely, making this simple for the programmer. The interesting part is the compilation strategy:</p>
<p>Functions that just call themselves are easy. As functions are compiled into structures with a <code>(-&gt;)</code> instance, the <code>call</code> method can just recursively call itself.</p>
<p>Mutually recursive functions are more challenging. A naive approach would be to include each</p>
<p>First, functions are placed into recursive groups by forming a graph of which call each other.</p>
<p>n the back-end</p>
<p>In principle, this</p>
<p>What is happening here is that</p>
<p>In WTy2 recursion is simple! Functions can refer to themselves or other functions in the same or above scope in their bodies. There is no dedicated <code>letrec</code> binding or similar: all function bindings are recursive. Variables that are not functions (RHS is not surrounded by - possibly implicit - braces)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constraints"><a class="header" href="#constraints">Constraints</a></h1>
<p>Constraints in WTy2 are used to pass evidence of equality or type membership. As WTy2 retains full information on the constructors used to create a value via the tags, they can be entirely erased at runtime (i.e: Haskell-style dictionary-passing is unnecessary) but implementation strategy is still a work in progress.
Indeed given current design for overlap of instances, dispatch can reqire arbitrary computation, meaning dictionary-passing could turn out to be a major optimisation.</p>
<h2 id="constraint-operators"><a class="header" href="#constraint-operators">Constraint Operators:</a></h2>
<ul>
<li>
<p><code>x :: t</code> = Dual to the binding operator <code>:</code>. Variable <code>x</code> is a member of the type <code>t</code>.</p>
</li>
<li>
<p><code>t &lt;:: u</code> = Dual to the binding operator <code>&lt;:</code>. Type <code>t</code> is an instance head of instanceable type <code>u</code>.</p>
</li>
<li>
<p><code>x ~ y</code> = Variable <code>x</code> is equal to <code>y</code>. Specifically, reduces to the same normal form, or if a function, is extensionally equal.</p>
</li>
<li>
<p><code>c /\ d</code> = A <strong>constraint conjunction</strong>. Both constraint <code>c</code> and constraint <code>d</code> are derivable.</p>
</li>
<li>
<p><code>c =&gt; d</code> = A <strong>constraint implication</strong>. Constraint <code>d</code> is derivable if constraint <code>c</code> is assumed.</p>
</li>
<li>
<p><code>for(t, f)</code> = A <strong>quantified constraint</strong>. Function taking argument of type <code>t</code> and returning a constraint, <code>f</code> returns a derivable constraint for every value of type <code>t</code>.</p>
<p>Example usage: <code>for(x: Int, y: Int) { x + y ~ y + x }</code> represents the constraint that <code>(+)</code> on <code>Int</code>s is commutative.</p>
</li>
<li>
<p>Constraints, like types, are first-class. The type of constraints is <code>Constraint</code> and so arbitrary expressions of this type can also appear inside constraints.</p>
</li>
</ul>
<p>A constraint for subtyping (i.e: all values of one type are members of another) is intentionally omitted from the source syntax. Firstly, this can actually be defined manually with relative ease using quantified constraints:</p>
<pre><code class="language-WTy2">subtype(t, u) = for(x: t) { x :: u }
</code></pre>
<p>But further, I am currently of the opinion that <code>(&lt;:)</code>/<code>(&lt;::)</code> should cover the VAST majority of subtyping needs, without introducing tons of ambiguity usually associated with such a feature.</p>
<h2 id="constrained-by--2"><a class="header" href="#constrained-by--2">Constrained By <code>(&lt;&lt;=)</code></a></h2>
<p>WTy2 features a built-in dependent operator that places additional constraints on values of a type. When used on the argument and return type of a function, this has the interpretation of defining <strong>requires</strong> and <strong>ensures</strong> contracts, respectively.</p>
<p>The <code>&lt;&lt;=</code> operator has the following type signature:</p>
<pre><code class="language-WTy2">(&lt;&lt;=) : (a: Type, f: a -&gt; Constraint) -&gt; Type
</code></pre>
<p>To construct a value of type <code>a &lt;&lt;= b</code> from a value <code>x</code> of type <code>a</code>, <code>b(x)</code> must be in the context. Matching on a value of type <code>(x: a) &lt;&lt;= b</code> is similar to matching on a value of type <code>a</code>, but <code>b(x)</code> is added to the context.</p>
<p>Another interpretation of this operator that might be more intuitive for programmers who have used languages with dependent types before is as a more limited version of a dependent pair, where the second element must be an erased constraint.</p>
<p>An approximation of this operator in Idris2 (but for which construction and matching is not implicit) could be defined like so (using boolean predicates lifted to the type level instead of Haskell-style constraints which Idris2 does not really have https://www.idris-lang.org/docs/idris2/current/base_docs/docs/Data.So.html):</p>
<pre><code class="language-idris">
data (&lt;&lt;=) : (a: Type) -&gt; (p: a -&gt; Bool) -&gt; Type where
  Mk : (x: a) -&gt; (f: So (p x)) -&gt; ((&lt;&lt;=) a p)

infix 4 &lt;&lt;=
</code></pre>
<p>An example use would be to restrict the integers received by a function:</p>
<pre><code class="language-idris">total
foo : (Nat &lt;&lt;= \x =&gt; 1 &lt;= x &amp;&amp; x &lt;= 3) -&gt; ()
foo (Mk 1 {f=Oh}) = ()
foo (Mk 2 {f=Oh}) = ()
foo (Mk 3 {f=Oh}) = ()
</code></pre>
<p><sup class="footnote-reference"><a href="#note">1</a></sup></p>
<p>We can see that although <code>foo</code> only matches on the natural number being <code>1</code>, <code>2</code> or <code>3</code>, the function is still correctly checked as <code>total</code>, as we must also pass a proof that the <code>Nat</code> is in the range <code>[1-3]</code>.</p>
<p>The equivalent WTy2 declaration of <code>foo</code> is:</p>
<pre><code class="language-WTy2">foo(x: Nat) &lt;&lt;= { 1 &lt;= x &amp;&amp; x &lt;= 3 ~ True }
</code></pre>
<p>Note in this signature, <code>foo</code> is declared as a function which takes an argument of type <code>(x: Nat) &lt;&lt;= { 1 &lt;= x &amp;&amp; x &lt;= 3 ~ True }</code>. This idea extends, we could define a type synonym and use that instead:</p>
<pre><code class="language-WTy2">type NatBetween(min: Nat, max: Nat)
    = Nat &lt;&lt;= { min &lt;= it &amp;&amp; it &lt;= max ~ True }

foo(x: NatBetween(1, 3))
</code></pre>
<h3 id="design-note-equivalent-constraints-1"><a class="header" href="#design-note-equivalent-constraints-1">Design Note: Equivalent Constraints</a></h3>
<p>You may notice that as constraints can contain arbitrary expressions, we could formulate semantically-equivalent constraints in many different ways. For example, we could write <code>{ contains([1, 2, 3], it) ~ True }</code>, or even <code>{ max(1, min(3, it)) ~ it }</code>. That these constraints do indeed imply each other though, is not always obvious (expecially to the typechecker).</p>
<p>This is arguably the main pain-point with dependent types. Proving that one constraint implies another can be tiresome and clutter up code significantly. Refinement type systems solve this through restricting constraints to those that can be proved with an SMT solver, but this is often overly limiting. WTy2 attempts to provide some of the ergonomics of refinement types without the restrictions through the ability to write and use implicit <code>proof</code>s.</p>
<p><sup class="footnote-reference"><a href="#note">1</a></sup> As a side note, on the current Idris2 version 0.6.0, if <code>x &lt;= 3</code> is replaced with <code>x &lt; 4</code>, the example breaks, saying case <code>foo (Mk (S (S (S (S _)))) _)</code> is not covered. This seems like a bug.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modes"><a class="header" href="#modes">Modes</a></h1>
<p>WTy2 is designed to be a language which can be implemented very efficiently, and give programmers control over performance. At the same time, WTy2 is not Rust: implementing a full-on borrow checker and requiring all references to track lifetimes in WTy2 programs seems excessive. To try and strike a middle-ground, WTy2 takes inspiration from some of the recent work Jane Street has done with OCAML <a href="https://blog.janestreet.com/oxidizing-ocaml-locality/">https://blog.janestreet.com/oxidizing-ocaml-locality/</a>, <a href="https://blog.janestreet.com/oxidizing-ocaml-ownership/">https://blog.janestreet.com/oxidizing-ocaml-ownership/</a>.</p>
<p>TODO...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-debates"><a class="header" href="#syntax-debates">Syntax Debates</a></h1>
<p><a href="https://wiki.haskell.org/Wadler&#x27;s_Law">https://wiki.haskell.org/Wadler's_Law</a></p>
<p>Syntax is hard, and discussions about it generally go nowhere...</p>
<p>...so let's discuss syntax!</p>
<h2 id="enforced-capitalisation-convention"><a class="header" href="#enforced-capitalisation-convention">Enforced Capitalisation Convention</a></h2>
<p>In functional languages, it is often easy to have an ambiguity with irrefutable pattern matches vs function definitions. Consider in Haskell:</p>
<pre><code class="language-hs">foo = ...
  where
    {- Something -} i = ...
</code></pre>
<p>Haskell gets around the ambiguity here by enforcing a simple capitalisation convention: constructors must start with a capital letter, and functions must start with a lowercase one.</p>
<pre><code class="language-hs">foo = ...
  where
    Bar i = ... -- Pattern match
    bar i = ... -- Local function definition
</code></pre>
<p>WTy2 has a similar potential ambiguity, and it is even more prevalent, given the rule that <code>f: t -&gt; u</code> can be written as <code>f(t): u</code> (so the ambiguity is possible even inside patterns).</p>
<p>One obvious solution is to copy Haskell's homework: data constructors are capitalised and variables are not. This rule fits well with WTy2's syntax in general: types should be capitalised, and this makes sense because types, like data constructors, are also matchable.</p>
<p>However, there are downsides. The most compelling from my perspective is how non-latin alphabets do not necessarily contain capital letters. I do not believe this is quite as significant of an issue as sometimes presented (a convention for code written in those alphabets could easily be created where data constructors/types must start with a latin-alphabet capital letter, say <code>M</code> for <code>matchable</code>) but even so, it is not ideal.</p>
<p>The alternative is to use some dedicated keyword/symbol to disambuate. Perhaps <code>fn</code> prefixing all functions written in <code>f(t): u</code>-style or <code>match</code> prefixing all irrefutable pattern matches.</p>
<p>Using <code>fn</code> keyword on functions</p>
<pre><code class="language-WTy2">takesFunctionAndMatches(fn foo(Int): Int, Foo(x)) {
    fn bar(y: Int) = foo(y);
    Bar(z) = x;
    ...
}
</code></pre>
<p>Using <code>match</code> keyword on matches</p>
<pre><code>takesFunctionAndMatches(foo(Int): Int, match Foo(x)) {
    bar(y: Int) = foo(y);
    match Bar(z) = x;
}
</code></pre>
<p>Perhaps some compromise is possible: capitalised = assume match, lowercase = assume function but then can use either keyword to override. This might be an overkill solution, but it seems promising.</p>
<h2 id="bindingconstraint-operators"><a class="header" href="#bindingconstraint-operators">Binding/Constraint Operators</a></h2>
<p>Currently, I am liking:</p>
<div class="table-wrapper"><table><thead><tr><th>Binding</th><th>Constraint</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>x : t</code></td><td><code>x :: t</code></td><td><code>x</code> is of type <code>t</code></td></tr>
<tr><td><code>t &lt;=: u</code></td><td><code>t &lt;=| u</code></td><td><code>t</code> is an instance head of <code>u</code></td></tr>
<tr><td><code>t &lt;: u</code></td><td><code>t &lt;| </code></td><td><code>t</code> is a subtype of <code>u</code></td></tr>
<tr><td><code>x ~: y</code></td><td><code>x ~ y</code></td><td><code>x</code> reduces to <code>y</code></td></tr>
</tbody></table>
</div>
<p>But it has a few problems:</p>
<ul>
<li><code>(&lt;=:)</code>/<code>(&lt;=|)</code> can easily look either like a combo of less-than-equal <code>(&lt;=)</code> and <code>(:)</code>/<code>(|)</code>, which with the context of subtyping being a combo of <code>(&lt;)</code> and <code>(:)</code>/<code>(|)</code> doesn't make much sense (instance head is a MORE restrictive relation, not more!) Alternatively they look a bit like a reversed implies <code>(=&gt;)</code> which they are ALSO unrelated to!</li>
<li>The instance head operator <code>(&lt;=:)</code> is more characters than subtyping <code>(&lt;:)</code>, but will likely be used MORE in practice.</li>
<li>With <code>(:)</code>, <code>(::)</code>, and <code>(&lt;:)</code> taken, what should cons be? <code>(:&gt;)</code> could very easily be misinterpreted as a flipped version of <code>(&lt;:)</code>.</li>
<li>Less important, but <code>(~:)</code> looks ugly IMO.</li>
</ul>
<p>And there are a LOT of alternatives:</p>
<ul>
<li>Use keywords/infix functions instead of operators. E.g: <code>x is t</code> instead of <code>x :: t</code>, or <code>instance t for u</code> instead of <code>t &lt;=: u</code>.</li>
<li>Make the common pattern for constraint (except for <code>(~)</code>) be to add a second colon. E.g: <code>(&lt;::)</code>, <code>(&lt;=::)</code> (note Firacode ligatures does not display the latter as intended though!)</li>
<li>Instead of <code>(::)</code>, all types types implement <code>Any -&gt; Constraint</code> so instead of <code>x :: Int</code> you would write <code>Int(x)</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
